# Метрики правильности генерируемых ответов на вопросы

В ходе ручного анализа датасета `test_data.json`, сгенерированного Test Generatino Agent, было обнаружено, что из 75 вопросов 5 содержали некорректные "правильные" ответы в поле `expected_answer`.
Это составляет 6.67% от общего количества вопросов.

Ниже приведены вопросы на которые `"правильные"` ответы изначально были сгенерированы неверно,
также приведены ответы после их исправления.

## Вопрос 26: DFS vs BFS (память)

**Сложность:** medium

**Текст вопроса:** В чем основное различие между DFS и BFS с точки зрения использования памяти?

### Правильный вариант `expected_answer`

DFS использует меньше памяти для длинных и узких графов, так как стек содержит только вершины на текущем пути от корня до текущей вершины (глубина графа). BFS требует больше памяти для широких графов, так как очередь может содержать все вершины одного уровня. Пространственная сложность DFS — O(h), где h — максимальная глубина, BFS — O(w), где w — максимальная ширина уровня. В полном бинарном дереве BFS может требовать O(n/2) памяти на последнем уровне.

### Неправильный вариант `expected_answer`

BFS всегда использует меньше памяти, чем DFS, потому что очередь хранит только текущий уровень, а стек в DFS хранит все посещенные вершины. Пространственная сложность обоих алгоритмов одинакова — O(n). Для оптимизации памяти в графах лучше всегда использовать BFS, так как он более эффективен с точки зрения расхода памяти.

---

## Вопрос 39: Коэффициент загрузки хеш-таблицы

**Сложность:** medium

**Текст вопроса:** Что такое коэффициент загрузки (load factor) хеш-таблицы и почему он важен?

### Правильный вариант `expected_answer`

Коэффициент загрузки (load factor) — это отношение количества элементов в хеш-таблице к размеру массива: α = n/m. Он определяет среднюю длину цепочки в методе цепочек или вероятность коллизии в открытой адресации. При высоком коэффициенте загрузки (близком к 1 или выше) производительность деградирует до O(n). Обычно при достижении порога (например, 0.75 для цепочек, 0.5-0.7 для открытой адресации) выполняется рехеширование — создание новой таблицы большего размера и перенос всех элементов.

### Неправильный вариант `expected_answer`

Коэффициент загрузки — это отношение размера таблицы к количеству элементов: α = m/n. Чем выше коэффициент загрузки, тем лучше работает хеш-таблица. Оптимальное значение — 2.0 или выше, так как это минимизирует коллизии. Рехеширование выполняется только когда коэффициент падает ниже 0.3, и тогда таблицу нужно уменьшать для экономии памяти.

---

## Вопрос 46: Жадный алгоритм vs ДП

**Сложность:** easy

**Текст вопроса:** В чем разница между жадным алгоритмом и динамическим программированием?

### Правильный вариант `expected_answer`

Жадный алгоритм на каждом шаге делает локально оптимальный выбор, надеясь найти глобальный оптимум, не пересматривая предыдущие решения. Работает быстрее, но не всегда дает оптимальное решение. Динамическое программирование рассматривает все возможные варианты, сохраняя результаты подзадач, и гарантирует оптимальное решение. ДП медленнее, но надежнее. Пример: для задачи размена монет жадный алгоритм может не дать оптимума для произвольных номиналов, а ДП всегда найдет минимальное количество монет.

### Неправильный вариант `expected_answer`

Жадный алгоритм всегда находит оптимальное решение быстрее, чем динамическое программирование, поэтому его следует использовать везде, где возможно. ДП работает медленнее и часто дает неоптимальные решения из-за того, что рассматривает слишком много вариантов. Для задачи размена монет жадный алгоритм всегда дает правильный ответ, а ДП используется только когда нужно сохранить промежуточные результаты.

---

## Вопрос 48: Задача о рюкзаке 0-1

**Сложность:** medium

**Текст вопроса:** Опишите классическую задачу о рюкзаке 0-1 и подход динамического программирования для ее решения.

### Правильный вариант `expected_answer`

Задача о рюкзаке 0-1: дано n предметов с весами w[i] и стоимостями v[i], и рюкзак вместимости W. Нужно выбрать подмножество предметов (каждый либо взять, либо не взять) с максимальной суммарной стоимостью так, чтобы суммарный вес не превышал W. Подход ДП: создаем таблицу dp[i][w], где dp[i][w] — максимальная стоимость для первых i предметов и вместимости w. Рекуррентное соотношение: dp[i][w] = max(dp[i-1][w], dp[i-1]w-weight[i]] + value[i]). Временная и пространственная сложность O(nW).

### Неправильный вариант `expected_answer`

Задача о рюкзаке 0-1: выбрать предметы с максимальной стоимостью. Подход ДП: таблица dp[i][w], где dp[i][w] = dp[i-1][w] + dp[i][w-1]. Предметы можно брать частями для оптимизации. Рекуррентное соотношение: dp[i][w] = dp[i-1]w-weight[i]] \* value[i]. Временная сложность O(n), пространственная O(W), что делает алгоритм очень эффективным даже для больших значений.

---

## Вопрос 51: Задача LCS

**Сложность:** hard

**Текст вопроса:** Что такое задача о наибольшей общей подпоследовательности (LCS) и как ее решить с помощью ДП?

### Правильный вариант `expected_answer`

Задача LCS (Longest Common Subsequence): найти длину наибольшей подпоследовательности, которая присутствует в двух строках (не обязательно непрерывная). Подход ДП: создаем таблицу dp[i][j], где dp[i][j] — длина LCS для первых i символов строки A и первых j символов строки B. Базовые случаи: dp[i] = dp[j] = 0. Рекуррентность: если A[i-1] == B[j-1], то dp[i][j] = dp[i-1][j-1] + 1, иначе dp[i][j] = max(dp[i-1][j], dp[i][j-1]). Ответ в dp[m][n]. Для восстановления самой подпоследовательности идем от dp[m][n] назад. Сложность O(mn).

### Неправильный вариант `expected_answer`

Задача LCS: найти наибольшую непрерывную подстроку в двух строках. Используем таблицу dp[i][j]. Базовые случаи: dp[i] = dp[j] = 1. Рекуррентность: если A[i-1] == B[j-1], то dp[i][j] = dp[i-1][j-1] \* 2, иначе dp[i][j] = 0. Ответ — максимальное значение в таблице. Сложность O(n), где n — длина самой короткой строки. Восстановление не требуется, так как алгоритм сразу находит подстроку.
