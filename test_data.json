[
  {
    "test_id": "443043f6-62ef-4c54-ae2e-3705ac7f4f55",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какова временная сложность сортировки пузырьком в худшем случае?",
        "expected_answer": "O(n²), где n - количество элементов массива",
        "key_points": [
          "Квадратичная сложность",
          "Вложенные циклы",
          "Сравнение каждого элемента"
        ]
      },
      {
        "question_id": 2,
        "question_text": "В чем основная идея алгоритма сортировки пузырьком?",
        "expected_answer": "Последовательное сравнение соседних элементов и их обмен, если они стоят в неправильном порядке. Более тяжелые элементы постепенно всплывают вверх.",
        "key_points": [
          "Сравнение соседних элементов",
          "Обмен элементов",
          "Всплытие максимума"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Является ли сортировка пузырьком устойчивой?",
        "expected_answer": "Да, сортировка пузырьком является устойчивой, так как не меняет относительный порядок равных элементов.",
        "key_points": [
          "Устойчивая сортировка",
          "Сохранение порядка",
          "Равные элементы"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова временная сложность сортировки пузырьком в лучшем случае?",
        "expected_answer": "O(n) при использовании флага для проверки завершения сортировки, когда массив уже отсортирован.",
        "key_points": [
          "Линейная сложность",
          "Оптимизация с флагом",
          "Отсортированный массив"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Сколько проходов требуется для полной сортировки массива из n элементов?",
        "expected_answer": "В худшем случае требуется n-1 проходов по массиву.",
        "key_points": [
          "n-1 проходов",
          "Каждый проход поднимает элемент",
          "Последний элемент не требует прохода"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Какова пространственная сложность сортировки пузырьком?",
        "expected_answer": "O(1), так как сортировка происходит на месте без использования дополнительной памяти.",
        "key_points": [
          "Константная память",
          "Сортировка на месте",
          "Нет дополнительных структур"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Как можно оптимизировать классический алгоритм сортировки пузырьком?",
        "expected_answer": "Использовать флаг для отслеживания обменов: если на проходе не было обменов, массив отсортирован. Также можно уменьшать границу прохода после каждой итерации.",
        "key_points": [
          "Флаг обменов",
          "Ранняя остановка",
          "Уменьшение границ"
        ]
      },
      {
        "question_id": 8,
        "question_text": "В каких случаях сортировка пузырьком может быть предпочтительнее быстрой сортировки?",
        "expected_answer": "Для небольших массивов или почти отсортированных данных, где сортировка пузырьком может работать за O(n) с оптимизацией.",
        "key_points": [
          "Малые массивы",
          "Почти отсортированные данные",
          "Простота реализации"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Что происходит с самым большим элементом после первого прохода сортировки пузырьком?",
        "expected_answer": "Самый большой элемент гарантированно окажется на последней позиции массива.",
        "key_points": [
          "Всплытие максимума",
          "Последняя позиция",
          "Гарантия после прохода"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Напишите псевдокод основного цикла сортировки пузырьком.",
        "expected_answer": "for i from 0 to n-1: for j from 0 to n-i-2: if arr[j] > arr[j+1]: swap(arr[j], arr[j+1])",
        "key_points": [
          "Внешний цикл по проходам",
          "Внутренний цикл для сравнений",
          "Обмен соседних элементов"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "abacf69d-04dc-419e-b798-de01ba4abbea",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какова средняя временная сложность быстрой сортировки?",
        "expected_answer": "O(n log n), где n - количество элементов массива.",
        "key_points": [
          "Логарифмическое разделение",
          "n сравнений на уровень",
          "log n уровней рекурсии"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Опишите основную идею алгоритма быстрой сортировки.",
        "expected_answer": "Выбор опорного элемента (pivot), разделение массива на элементы меньше и больше опорного, рекурсивная сортировка полученных подмассивов.",
        "key_points": [
          "Разделяй и властвуй",
          "Выбор опорного элемента",
          "Рекурсивное разделение"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Какова временная сложность быстрой сортировки в худшем случае?",
        "expected_answer": "O(n²) - когда опорный элемент всегда выбирается как минимальный или максимальный элемент.",
        "key_points": [
          "Квадратичная сложность",
          "Несбалансированное разделение",
          "Плохой выбор pivot"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Является ли быстрая сортировка устойчивой?",
        "expected_answer": "Нет, классическая реализация быстрой сортировки не является устойчивой, так как может изменять относительный порядок равных элементов.",
        "key_points": [
          "Неустойчивая сортировка",
          "Изменение порядка",
          "Перестановка элементов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какова пространственная сложность быстрой сортировки?",
        "expected_answer": "O(log n) для хранения стека рекурсии в среднем случае, O(n) в худшем случае.",
        "key_points": [
          "Стек рекурсии",
          "Логарифмическая глубина",
          "Зависит от выбора pivot"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Как выбор опорного элемента влияет на производительность?",
        "expected_answer": "Хороший выбор pivot (медиана, случайный элемент) обеспечивает сбалансированное разделение и O(n log n). Плохой выбор приводит к O(n²).",
        "key_points": [
          "Влияние на разделение",
          "Случайный выбор",
          "Медиана из трех"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Что происходит в процедуре разделения (partition)?",
        "expected_answer": "Элементы меньше опорного перемещаются влево, больше опорного - вправо. Опорный элемент устанавливается в правильную позицию.",
        "key_points": [
          "Разделение на части",
          "Перестановка элементов",
          "Финальная позиция pivot"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Можно ли реализовать быструю сортировку без рекурсии?",
        "expected_answer": "Да, можно использовать явный стек для хранения границ подмассивов вместо рекурсивных вызовов.",
        "key_points": [
          "Итеративная реализация",
          "Явный стек",
          "Эмуляция рекурсии"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Какая стратегия выбора pivot считается наиболее эффективной?",
        "expected_answer": "Метод медианы из трех: выбор среднего значения из первого, среднего и последнего элементов массива.",
        "key_points": [
          "Медиана из трех",
          "Защита от худшего случая",
          "Баланс разделения"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Почему быстрая сортировка часто быстрее сортировки слиянием на практике?",
        "expected_answer": "Лучшая локальность данных, меньше операций копирования, работа на месте, эффективное использование кеша процессора.",
        "key_points": [
          "Локальность памяти",
          "Кеш-эффективность",
          "Меньше копирований"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "1c6d706e-44ee-4d46-9a49-ce0bc598ede5",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какова временная сложность сортировки слиянием во всех случаях?",
        "expected_answer": "O(n log n) - одинакова для лучшего, среднего и худшего случаев.",
        "key_points": [
          "Гарантированная сложность",
          "Независима от входных данных",
          "n log n операций"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Опишите основной принцип работы сортировки слиянием.",
        "expected_answer": "Рекурсивное разделение массива пополам до одноэлементных подмассивов, затем последовательное слияние отсортированных подмассивов.",
        "key_points": [
          "Разделяй и властвуй",
          "Рекурсивное разделение",
          "Слияние отсортированных частей"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Является ли сортировка слиянием устойчивой?",
        "expected_answer": "Да, сортировка слиянием является устойчивой при правильной реализации процедуры слияния.",
        "key_points": [
          "Устойчивая сортировка",
          "Сохранение порядка",
          "Правильная реализация merge"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность сортировки слиянием?",
        "expected_answer": "O(n) - требуется дополнительный массив для слияния отсортированных частей.",
        "key_points": [
          "Линейная память",
          "Дополнительный массив",
          "Временный буфер"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Как работает процедура слияния двух отсортированных массивов?",
        "expected_answer": "Сравниваются первые элементы каждого массива, меньший копируется в результат, указатель сдвигается. Процесс продолжается до исчерпания обоих массивов.",
        "key_points": [
          "Два указателя",
          "Сравнение элементов",
          "Копирование минимума"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Сколько уровней рекурсии создается при сортировке слиянием?",
        "expected_answer": "log₂(n) уровней, где n - размер массива, так как массив делится пополам на каждом уровне.",
        "key_points": [
          "Логарифмическая глубина",
          "Деление пополам",
          "log n уровней"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Можно ли реализовать сортировку слиянием с O(1) дополнительной памятью?",
        "expected_answer": "Теоретически да, но такая реализация сложна и теряет устойчивость. На практике используется O(n) дополнительной памяти.",
        "key_points": [
          "Теоретически возможно",
          "Сложная реализация",
          "Потеря устойчивости"
        ]
      },
      {
        "question_id": 8,
        "question_text": "В чем преимущество сортировки слиянием перед быстрой сортировкой?",
        "expected_answer": "Гарантированная O(n log n) сложность в худшем случае и устойчивость сортировки.",
        "key_points": [
          "Предсказуемая производительность",
          "Устойчивость",
          "Нет худшего случая O(n²)"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Как можно оптимизировать сортировку слиянием для небольших массивов?",
        "expected_answer": "Использовать сортировку вставками для подмассивов размером меньше порогового значения (обычно 10-20 элементов).",
        "key_points": [
          "Гибридный подход",
          "Сортировка вставками",
          "Пороговое значение"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Подходит ли сортировка слиянием для работы с большими файлами на диске?",
        "expected_answer": "Да, внешняя сортировка слиянием идеально подходит для данных, не помещающихся в оперативную память.",
        "key_points": [
          "Внешняя сортировка",
          "Работа с диском",
          "Последовательный доступ"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "04d998d5-d082-4be0-89ce-29bba6d8660f",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какова временная сложность бинарного поиска?",
        "expected_answer": "O(log n), где n - количество элементов в массиве",
        "key_points": [
          "Логарифмическая сложность",
          "Деление пополам",
          "Уменьшение области поиска"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какое условие необходимо для работы бинарного поиска?",
        "expected_answer": "Массив должен быть отсортирован",
        "key_points": [
          "Отсортированный массив",
          "Упорядоченные данные",
          "Монотонность"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Опишите основной принцип работы бинарного поиска",
        "expected_answer": "Сравнение искомого элемента с средним элементом массива, затем поиск продолжается в левой или правой половине в зависимости от результата сравнения",
        "key_points": [
          "Сравнение с серединой",
          "Выбор половины",
          "Рекурсивное деление"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Сколько итераций максимально требуется для поиска в массиве из 1000 элементов?",
        "expected_answer": "Примерно 10 итераций, так как log₂(1000) ≈ 10",
        "key_points": [
          "Логарифм от размера",
          "10 итераций",
          "Эффективность"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Можно ли применить бинарный поиск к связному списку?",
        "expected_answer": "Теоретически да, но неэффективно, так как отсутствует прямой доступ к элементам по индексу. Сложность становится O(n log n)",
        "key_points": [
          "Требуется индексация",
          "Неэффективно для списков",
          "Нужен случайный доступ"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Какое значение вернется, если элемент не найден?",
        "expected_answer": "Обычно возвращается -1 или специальное значение, указывающее на отсутствие элемента",
        "key_points": [
          "Признак отсутствия",
          "Конвенция -1",
          "Специальное значение"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Можно ли использовать бинарный поиск для поиска первого вхождения элемента?",
        "expected_answer": "Да, необходимо модифицировать алгоритм: при нахождении элемента продолжить поиск в левой части",
        "key_points": [
          "Модификация алгоритма",
          "Поиск в левой части",
          "Первое вхождение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "В чем разница между рекурсивной и итеративной реализацией?",
        "expected_answer": "Рекурсивная использует стек вызовов (O(log n) памяти), итеративная использует O(1) памяти. Итеративная обычно быстрее",
        "key_points": [
          "Использование памяти",
          "Стек рекурсии",
          "Производительность"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Какие проблемы могут возникнуть при вычислении середины массива?",
        "expected_answer": "Переполнение при вычислении (left + right) / 2. Правильно использовать left + (right - left) / 2",
        "key_points": [
          "Переполнение целых чисел",
          "Безопасное вычисление",
          "Альтернативная формула"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Можно ли использовать бинарный поиск для поиска минимума в циклически отсортированном массиве?",
        "expected_answer": "Да, модифицированный бинарный поиск может найти точку разрыва за O(log n)",
        "key_points": [
          "Модификация алгоритма",
          "Циклическая сортировка",
          "Поиск точки разрыва"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "757838b4-c134-45f3-8df5-fe908df5cdb3",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какова средняя временная сложность операций вставки, поиска и удаления в хеш-таблице?",
        "expected_answer": "O(1) - константное время при хорошей хеш-функции и низком коэффициенте заполнения",
        "key_points": [
          "Константная сложность",
          "Зависит от хеш-функции",
          "Коэффициент заполнения"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Что такое коллизия в хеш-таблице?",
        "expected_answer": "Ситуация, когда два разных ключа получают одинаковое хеш-значение и претендуют на одну ячейку",
        "key_points": [
          "Совпадение хешей",
          "Конфликт ключей",
          "Неизбежность коллизий"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Назовите два основных метода разрешения коллизий",
        "expected_answer": "Метод цепочек (chaining) и открытая адресация (open addressing)",
        "key_points": [
          "Метод цепочек",
          "Открытая адресация",
          "Способы разрешения"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Что такое коэффициент заполнения (load factor)?",
        "expected_answer": "Отношение количества элементов к размеру таблицы. При превышении порога (обычно 0.75) происходит перехеширование",
        "key_points": [
          "Отношение элементов",
          "Пороговое значение",
          "Триггер перехеширования"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Опишите метод цепочек для разрешения коллизий",
        "expected_answer": "Каждая ячейка таблицы содержит связный список элементов с одинаковым хешем. При коллизии элемент добавляется в список",
        "key_points": [
          "Связные списки",
          "Добавление в цепочку",
          "Дополнительная память"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Что такое перехеширование (rehashing)?",
        "expected_answer": "Процесс создания новой таблицы большего размера и переноса всех элементов с пересчетом хеш-значений",
        "key_points": [
          "Увеличение размера",
          "Перенос элементов",
          "Пересчет хешей"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие свойства должна иметь хорошая хеш-функция?",
        "expected_answer": "Детерминированность, равномерное распределение значений, быстрое вычисление, минимизация коллизий",
        "key_points": [
          "Детерминизм",
          "Равномерность",
          "Быстрота вычисления"
        ]
      },
      {
        "question_id": 8,
        "question_text": "В чем преимущество метода цепочек перед открытой адресацией?",
        "expected_answer": "Более простая реализация удаления, отсутствие проблемы кластеризации, работа при высоком коэффициенте заполнения",
        "key_points": [
          "Простота удаления",
          "Нет кластеризации",
          "Высокая заполненность"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Что такое линейное пробирование (linear probing)?",
        "expected_answer": "Метод открытой адресации, где при коллизии проверяются последовательные ячейки: h(k), h(k)+1, h(k)+2, ...",
        "key_points": [
          "Последовательный поиск",
          "Открытая адресация",
          "Инкремент на 1"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какова сложность операций в худшем случае?",
        "expected_answer": "O(n) - когда все элементы имеют одинаковый хеш или при полной таблице с открытой адресацией",
        "key_points": [
          "Линейная сложность",
          "Все коллизии",
          "Худший случай"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "5d10bbd7-1848-4706-a8a3-a76a04eae533",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какова временная сложность доступа к элементу по индексу?",
        "expected_answer": "O(n), так как требуется последовательный обход от начала списка",
        "key_points": [
          "Линейная сложность",
          "Последовательный доступ",
          "Нет индексации"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность вставки элемента в начало списка?",
        "expected_answer": "O(1) - требуется только изменить указатель головы списка",
        "key_points": [
          "Константная сложность",
          "Изменение head",
          "Быстрая операция"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В чем главное преимущество связного списка перед массивом?",
        "expected_answer": "Динамическое изменение размера без перевыделения памяти и эффективная вставка/удаление в начале",
        "key_points": [
          "Динамический размер",
          "Нет перевыделения",
          "Эффективная вставка"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Что такое узел (node) связного списка?",
        "expected_answer": "Структура данных, содержащая значение и указатель на следующий узел",
        "key_points": [
          "Структура узла",
          "Данные и указатель",
          "Базовый элемент"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Как удалить узел из середины связного списка?",
        "expected_answer": "Найти предыдущий узел и перенаправить его указатель на узел после удаляемого, затем освободить память",
        "key_points": [
          "Поиск предыдущего",
          "Перенаправление указателя",
          "Освобождение памяти"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Что произойдет, если потерять указатель на голову списка?",
        "expected_answer": "Весь список станет недоступным, произойдет утечка памяти",
        "key_points": [
          "Потеря доступа",
          "Утечка памяти",
          "Критическая ошибка"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Как найти средний элемент списка за один проход?",
        "expected_answer": "Использовать два указателя: быстрый двигается на 2 шага, медленный на 1. Когда быстрый достигнет конца, медленный будет на середине",
        "key_points": [
          "Два указателя",
          "Разная скорость",
          "Один проход"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Какова пространственная сложность связного списка?",
        "expected_answer": "O(n), где n элементов плюс n указателей на следующие узлы",
        "key_points": [
          "Линейная память",
          "Данные и указатели",
          "Дополнительные накладные расходы"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Как обнаружить цикл в связном списке?",
        "expected_answer": "Алгоритм Флойда (заяц и черепаха): два указателя двигаются с разной скоростью, если есть цикл - они встретятся",
        "key_points": [
          "Алгоритм Флойда",
          "Два указателя",
          "Встреча в цикле"
        ]
      },
      {
        "question_id": 10,
        "question_text": "В чем недостаток связного списка по сравнению с массивом?",
        "expected_answer": "Отсутствие случайного доступа, больший расход памяти на указатели, плохая локальность кеша",
        "key_points": [
          "Нет прямого доступа",
          "Больше памяти",
          "Кеш-неэффективность"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "bfd9e497-db9d-4b98-9a3c-90d0dd5dbdbb",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Чем двусвязный список отличается от односвязного?",
        "expected_answer": "Каждый узел содержит два указателя: на следующий и предыдущий элементы",
        "key_points": [
          "Два указателя",
          "Прямой и обратный обход",
          "Дополнительная память"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность удаления узла, если есть указатель на него?",
        "expected_answer": "O(1) - можно напрямую изменить указатели соседних узлов без поиска предыдущего",
        "key_points": [
          "Константная сложность",
          "Прямой доступ к соседям",
          "Нет поиска"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Какой дополнительный расход памяти у двусвязного списка?",
        "expected_answer": "Дополнительный указатель на каждый узел, итого 2n указателей вместо n",
        "key_points": [
          "Двойной расход указателей",
          "2n памяти",
          "Компромисс производительности"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Можно ли обходить двусвязный список в обратном направлении?",
        "expected_answer": "Да, используя указатели prev можно двигаться от конца к началу",
        "key_points": [
          "Обратный обход",
          "Указатели prev",
          "Двунаправленность"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Как вставить элемент между двумя узлами?",
        "expected_answer": "Установить prev нового узла на левый узел, next на правый, затем обновить их указатели на новый узел",
        "key_points": [
          "Четыре изменения указателей",
          "Связь с соседями",
          "Последовательность операций"
        ]
      },
      {
        "question_id": 6,
        "question_text": "В каких структурах данных используются двусвязные списки?",
        "expected_answer": "LRU-кеш, деки (двусторонние очереди), редакторы текста для операций undo/redo",
        "key_points": [
          "LRU-кеш",
          "Деки",
          "Практическое применение"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Как удалить узел из двусвязного списка, имея только указатель на него?",
        "expected_answer": "Установить prev.next = node.next и next.prev = node.prev, затем освободить память узла",
        "key_points": [
          "Два изменения указателей",
          "Связь соседей",
          "Освобождение памяти"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Что такое циклический двусвязный список?",
        "expected_answer": "Список, где последний узел указывает на первый, а первый на последний, образуя кольцо",
        "key_points": [
          "Кольцевая структура",
          "Нет NULL указателей",
          "Циклический обход"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Какова временная сложность вставки в конец двусвязного списка с указателем tail?",
        "expected_answer": "O(1) - можно напрямую добавить после tail",
        "key_points": [
          "Константная сложность",
          "Указатель tail",
          "Быстрая вставка"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Чем двусвязный список лучше односвязного для реализации дека?",
        "expected_answer": "Позволяет эффективно (O(1)) добавлять и удалять элементы с обоих концов",
        "key_points": [
          "Операции с двух концов",
          "Константная сложность",
          "Идеален для дека"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "657e736d-9164-41fa-afcc-ca93cc961322",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какой принцип работы стека?",
        "expected_answer": "LIFO (Last In, First Out) - последним пришел, первым вышел",
        "key_points": [
          "LIFO принцип",
          "Последний элемент первым",
          "Порядок доступа"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какие основные операции поддерживает стек?",
        "expected_answer": "Push (добавление), Pop (удаление), Peek/Top (просмотр верхнего элемента), isEmpty (проверка пустоты)",
        "key_points": [
          "Push и Pop",
          "Peek",
          "Проверка пустоты"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Какова временная сложность операций push и pop?",
        "expected_answer": "O(1) - константное время для обеих операций",
        "key_points": [
          "Константная сложность",
          "Быстрые операции",
          "Эффективность"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Приведите примеры использования стека в программировании",
        "expected_answer": "Вызовы функций (call stack), отмена операций (undo), проверка скобочных последовательностей, обход графов (DFS)",
        "key_points": [
          "Call stack",
          "Undo/Redo",
          "Проверка скобок",
          "DFS"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Можно ли реализовать стек на основе массива?",
        "expected_answer": "Да, используя массив и указатель на вершину стека (top). При переполнении требуется расширение массива",
        "key_points": [
          "Массив и указатель",
          "Расширение при переполнении",
          "Простая реализация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Можно ли реализовать стек на основе связного списка?",
        "expected_answer": "Да, операции push и pop выполняются в начале списка за O(1)",
        "key_points": [
          "Связный список",
          "Операции в начале",
          "Динамический размер"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Что произойдет при попытке pop из пустого стека?",
        "expected_answer": "Возникнет ошибка underflow, необходимо выбросить исключение или вернуть специальное значение",
        "key_points": [
          "Stack underflow",
          "Обработка ошибки",
          "Проверка пустоты"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как использовать стек для проверки правильности скобочной последовательности?",
        "expected_answer": "При открывающей скобке - push, при закрывающей - pop и проверка соответствия. Стек должен быть пуст в конце",
        "key_points": [
          "Push для открывающих",
          "Pop для закрывающих",
          "Проверка соответствия"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Что такое вспомогательный стек (auxiliary stack)?",
        "expected_answer": "Дополнительный стек для отслеживания дополнительной информации, например минимума или максимума в основном стеке",
        "key_points": [
          "Дополнительная информация",
          "Отслеживание минимума",
          "Параллельная структура"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Можно ли реализовать две стеки в одном массиве эффективно?",
        "expected_answer": "Да, один стек растет от начала массива, другой от конца. Переполнение когда встречаются",
        "key_points": [
          "Два конца массива",
          "Навстречу друг другу",
          "Эффективное использование памяти"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "3fad7d06-174b-4ce9-b3e1-bdcf724a406d",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Какой принцип работы очереди?",
        "expected_answer": "FIFO (First In, First Out) - первым пришел, первым вышел",
        "key_points": [
          "FIFO принцип",
          "Порядок обработки",
          "Справедливость"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какие основные операции поддерживает очередь?",
        "expected_answer": "Enqueue (добавление в конец), Dequeue (удаление из начала), Front/Peek (просмотр первого), isEmpty",
        "key_points": [
          "Enqueue",
          "Dequeue",
          "Просмотр первого"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Какова временная сложность операций enqueue и dequeue?",
        "expected_answer": "O(1) при правильной реализации с указателями на начало и конец",
        "key_points": [
          "Константная сложность",
          "Два указателя",
          "Эффективность"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Что такое циклическая очередь?",
        "expected_answer": "Очередь на основе массива, где конец соединяется с началом, индексы вычисляются по модулю размера",
        "key_points": [
          "Кольцевой буфер",
          "Модульная арифметика",
          "Эффективное использование памяти"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Приведите примеры использования очередей",
        "expected_answer": "Обработка задач в ОС, BFS в графах, буферизация данных, очереди печати, обслуживание клиентов",
        "key_points": [
          "Планирование задач",
          "BFS",
          "Буферизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Чем отличается дек от обычной очереди?",
        "expected_answer": "Дек (двусторонняя очередь) позволяет добавлять и удалять элементы с обоих концов",
        "key_points": [
          "Двусторонний доступ",
          "Операции с двух концов",
          "Гибкость"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Как реализовать очередь на двух стеках?",
        "expected_answer": "Один стек для enqueue, другой для dequeue. При dequeue из пустого второго стека перекидываем все элементы из первого",
        "key_points": [
          "Два стека",
          "Перенос элементов",
          "Амортизированная O(1)"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Что такое приоритетная очередь?",
        "expected_answer": "Очередь, где элементы обрабатываются в порядке приоритета, а не времени добавления. Обычно реализуется на куче",
        "key_points": [
          "Приоритет элементов",
          "Куча",
          "Не FIFO"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Какие проблемы возникают при реализации очереди на массиве?",
        "expected_answer": "Смещение элементов при dequeue или неэффективное использование памяти. Решается циклическим буфером",
        "key_points": [
          "Смещение элементов",
          "Потеря места",
          "Циклический буфер"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Можно ли реализовать очередь на связном списке?",
        "expected_answer": "Да, операции enqueue в конец и dequeue из начала выполняются за O(1) при наличии указателей head и tail",
        "key_points": [
          "Связный список",
          "Два указателя",
          "Динамический размер"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "6cac8857-b22a-473e-ba8a-cca0ebc95139",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое двоичное дерево?",
        "expected_answer": "Иерархическая структура данных, где каждый узел имеет максимум двух потомков: левого и правого",
        "key_points": [
          "Иерархическая структура",
          "Максимум 2 потомка",
          "Узлы и связи"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Что такое корень дерева?",
        "expected_answer": "Верхний узел дерева, не имеющий родителя, от которого начинаются все остальные узлы",
        "key_points": [
          "Верхний узел",
          "Нет родителя",
          "Точка входа"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Что такое лист дерева?",
        "expected_answer": "Узел, не имеющий потомков (оба дочерних указателя равны NULL)",
        "key_points": [
          "Нет потомков",
          "Конечный узел",
          "NULL указатели"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова максимальная высота дерева с n узлами?",
        "expected_answer": "n-1 (когда дерево вырождается в связный список)",
        "key_points": [
          "Вырожденное дерево",
          "Список",
          "Худший случай"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какова минимальная высота полного двоичного дерева с n узлами?",
        "expected_answer": "floor(log₂(n)) - логарифм от числа узлов",
        "key_points": [
          "Логарифмическая высота",
          "Полное дерево",
          "Оптимальный случай"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Что такое полное двоичное дерево?",
        "expected_answer": "Дерево, где все уровни, кроме возможно последнего, полностью заполнены, и узлы на последнем уровне прижаты влево",
        "key_points": [
          "Заполненные уровни",
          "Прижаты влево",
          "Компактность"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Что такое совершенное двоичное дерево?",
        "expected_answer": "Дерево, где все внутренние узлы имеют ровно двух потомков, и все листья на одном уровне",
        "key_points": [
          "Все уровни заполнены",
          "2^h - 1 узлов",
          "Идеальная симметрия"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Сколько узлов в совершенном двоичном дереве высоты h?",
        "expected_answer": "2^(h+1) - 1 узлов",
        "key_points": [
          "Экспоненциальный рост",
          "Формула 2^h - 1",
          "Геометрическая прогрессия"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Как хранить двоичное дерево в массиве?",
        "expected_answer": "Корень в индексе 0, для узла i: левый потомок 2i+1, правый 2i+2, родитель (i-1)/2",
        "key_points": [
          "Формулы индексов",
          "Неявная структура",
          "Эффективно для полных деревьев"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какова пространственная сложность дерева с n узлами?",
        "expected_answer": "O(n) для узлов плюс O(n) для указателей на потомков, итого O(n)",
        "key_points": [
          "Линейная память",
          "Узлы и указатели",
          "Пропорционально размеру"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "fb798533-bf0f-4828-ab8d-5cf476ce9f85",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Назовите три основных способа обхода двоичного дерева",
        "expected_answer": "Прямой (pre-order), центрированный (in-order), обратный (post-order)",
        "key_points": [
          "Pre-order",
          "In-order",
          "Post-order"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Опишите порядок обхода Pre-order",
        "expected_answer": "Корень -> Левое поддерево -> Правое поддерево (NLR)",
        "key_points": [
          "Корень первым",
          "NLR порядок",
          "Префиксная нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "Опишите порядок обхода In-order",
        "expected_answer": "Левое поддерево -> Корень -> Правое поддерево (LNR)",
        "key_points": [
          "Корень в середине",
          "LNR порядок",
          "Инфиксная нотация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Опишите порядок обхода Post-order",
        "expected_answer": "Левое поддерево -> Правое поддерево -> Корень (LRN)",
        "key_points": [
          "Корень последним",
          "LRN порядок",
          "Постфиксная нотация"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какой обход дает отсортированную последовательность для бинарного дерева поиска?",
        "expected_answer": "In-order (центрированный) обход выдает элементы в возрастающем порядке",
        "key_points": [
          "In-order",
          "Отсортированная последовательность",
          "BST свойство"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Что такое обход по уровням (Level-order)?",
        "expected_answer": "Обход дерева уровень за уровнем слева направо, реализуется с помощью очереди",
        "key_points": [
          "Поуровневый обход",
          "Использование очереди",
          "BFS для деревьев"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какова временная сложность обхода дерева?",
        "expected_answer": "O(n), где n - количество узлов, так как каждый узел посещается ровно один раз",
        "key_points": [
          "Линейная сложность",
          "Один проход",
          "Все узлы"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Можно ли выполнить обход без рекурсии?",
        "expected_answer": "Да, используя явный стек для эмуляции рекурсии или алгоритм Морриса для обхода без дополнительной памяти",
        "key_points": [
          "Явный стек",
          "Алгоритм Морриса",
          "Итеративная реализация"
        ]
      },
      {
        "question_id": 9,
        "question_text": "Зачем нужен Post-order обход?",
        "expected_answer": "Для удаления дерева (сначала удаляем детей, потом родителя), вычисления выражений в постфиксной нотации",
        "key_points": [
          "Удаление дерева",
          "Постфиксные выражения",
          "Обработка потомков первыми"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Как реализовать итеративный In-order обход?",
        "expected_answer": "Использовать стек: идти влево до конца, затем извлекать из стека, обрабатывать узел и идти вправо",
        "key_points": [
          "Стек для узлов",
          "Путь влево",
          "Обработка из стека"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "85c8b899-a49b-4aad-80a2-8af3dfef2e74",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Сбалансированные деревья?",
        "expected_answer": "Сбалансированные деревья - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Сбалансированные деревья?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Сбалансированные деревья?",
        "expected_answer": "Сбалансированные деревья применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Сбалансированные деревья?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Сбалансированные деревья?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Сбалансированные деревья?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Сбалансированные деревья?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Сбалансированные деревья на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Сбалансированные деревья по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Сбалансированные деревья?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "04219300-ef70-4d89-8783-4287444c07b3",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое AVL-деревья?",
        "expected_answer": "AVL-деревья - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в AVL-деревья?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется AVL-деревья?",
        "expected_answer": "AVL-деревья применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность AVL-деревья?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование AVL-деревья?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у AVL-деревья?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для AVL-деревья?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать AVL-деревья на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность AVL-деревья по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для AVL-деревья?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "ecba075a-9d31-4c30-8075-c25f5e651557",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Красно-черные деревья?",
        "expected_answer": "Красно-черные деревья - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Красно-черные деревья?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Красно-черные деревья?",
        "expected_answer": "Красно-черные деревья применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Красно-черные деревья?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Красно-черные деревья?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Красно-черные деревья?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Красно-черные деревья?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Красно-черные деревья на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Красно-черные деревья по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Красно-черные деревья?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "8e905380-f438-456f-bdd1-bf24d04ca559",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое B-деревья?",
        "expected_answer": "B-деревья - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в B-деревья?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется B-деревья?",
        "expected_answer": "B-деревья применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность B-деревья?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование B-деревья?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у B-деревья?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для B-деревья?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать B-деревья на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность B-деревья по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для B-деревья?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "eeb2be50-fdab-49dd-8f21-3aa943053076",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Куча (Heap)?",
        "expected_answer": "Куча (Heap) - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Куча (Heap)?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Куча (Heap)?",
        "expected_answer": "Куча (Heap) применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Куча (Heap)?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Куча (Heap)?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Куча (Heap)?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Куча (Heap)?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Куча (Heap) на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Куча (Heap) по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Куча (Heap)?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "701a6ac3-9017-44d1-be6e-4a09f08d393e",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Приоритетная очередь?",
        "expected_answer": "Приоритетная очередь - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Приоритетная очередь?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Приоритетная очередь?",
        "expected_answer": "Приоритетная очередь применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Приоритетная очередь?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Приоритетная очередь?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Приоритетная очередь?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Приоритетная очередь?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Приоритетная очередь на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Приоритетная очередь по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Приоритетная очередь?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "356d69d2-6cc8-4550-b19d-872897ed9ac0",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Графы: представление?",
        "expected_answer": "Графы: представление - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Графы: представление?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Графы: представление?",
        "expected_answer": "Графы: представление применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Графы: представление?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Графы: представление?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Графы: представление?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Графы: представление?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Графы: представление на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Графы: представление по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Графы: представление?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "34cbd249-07b3-4a3b-b992-f4f406d89be1",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Поиск в глубину (DFS)?",
        "expected_answer": "Поиск в глубину (DFS) - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Поиск в глубину (DFS)?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Поиск в глубину (DFS)?",
        "expected_answer": "Поиск в глубину (DFS) применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Поиск в глубину (DFS)?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Поиск в глубину (DFS)?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Поиск в глубину (DFS)?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Поиск в глубину (DFS)?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Поиск в глубину (DFS) на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Поиск в глубину (DFS) по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Поиск в глубину (DFS)?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "ebc91468-e69d-43d8-a540-ab9ae966c79c",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Поиск в ширину (BFS)?",
        "expected_answer": "Поиск в ширину (BFS) - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Поиск в ширину (BFS)?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Поиск в ширину (BFS)?",
        "expected_answer": "Поиск в ширину (BFS) применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Поиск в ширину (BFS)?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Поиск в ширину (BFS)?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Поиск в ширину (BFS)?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Поиск в ширину (BFS)?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Поиск в ширину (BFS) на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Поиск в ширину (BFS) по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Поиск в ширину (BFS)?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "e1586d10-67c8-4980-b3f3-de021cb02832",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Алгоритм Дейкстры?",
        "expected_answer": "Алгоритм Дейкстры - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Алгоритм Дейкстры?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Алгоритм Дейкстры?",
        "expected_answer": "Алгоритм Дейкстры применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Алгоритм Дейкстры?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Алгоритм Дейкстры?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Алгоритм Дейкстры?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Алгоритм Дейкстры?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Алгоритм Дейкстры на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Алгоритм Дейкстры по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Алгоритм Дейкстры?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "2111c568-fa3f-4d81-aa69-2d77b3f3563c",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Алгоритм Беллмана-Форда?",
        "expected_answer": "Алгоритм Беллмана-Форда - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Алгоритм Беллмана-Форда?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Алгоритм Беллмана-Форда?",
        "expected_answer": "Алгоритм Беллмана-Форда применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Алгоритм Беллмана-Форда?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Алгоритм Беллмана-Форда?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Алгоритм Беллмана-Форда?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Алгоритм Беллмана-Форда?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Алгоритм Беллмана-Форда на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Алгоритм Беллмана-Форда по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Алгоритм Беллмана-Форда?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "ac6ff243-848b-4d9b-b5ff-22bd15fb42aa",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Алгоритм Флойда-Уоршелла - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Алгоритм Флойда-Уоршелла применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Алгоритм Флойда-Уоршелла на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Алгоритм Флойда-Уоршелла по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Алгоритм Флойда-Уоршелла?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "5feb25e1-2f67-4670-a63f-683f1c1b619a",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Минимальное остовное дерево?",
        "expected_answer": "Минимальное остовное дерево - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Минимальное остовное дерево?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Минимальное остовное дерево?",
        "expected_answer": "Минимальное остовное дерево применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Минимальное остовное дерево?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Минимальное остовное дерево?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Минимальное остовное дерево?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Минимальное остовное дерево?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Минимальное остовное дерево на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Минимальное остовное дерево по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Минимальное остовное дерево?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "6fa260e1-8d50-4245-ab9e-aab77dcce87b",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Алгоритм Прима?",
        "expected_answer": "Алгоритм Прима - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Алгоритм Прима?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Алгоритм Прима?",
        "expected_answer": "Алгоритм Прима применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Алгоритм Прима?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Алгоритм Прима?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Алгоритм Прима?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Алгоритм Прима?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Алгоритм Прима на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Алгоритм Прима по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Алгоритм Прима?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "927d65bc-3fb4-45c9-a05d-79decfb40e58",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Алгоритм Краскала?",
        "expected_answer": "Алгоритм Краскала - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Алгоритм Краскала?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Алгоритм Краскала?",
        "expected_answer": "Алгоритм Краскала применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Алгоритм Краскала?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Алгоритм Краскала?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Алгоритм Краскала?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Алгоритм Краскала?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Алгоритм Краскала на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Алгоритм Краскала по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Алгоритм Краскала?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "16886cb5-cb9f-43c6-8da8-add8bb16d451",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Топологическая сортировка?",
        "expected_answer": "Топологическая сортировка - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Топологическая сортировка?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Топологическая сортировка?",
        "expected_answer": "Топологическая сортировка применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Топологическая сортировка?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Топологическая сортировка?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Топологическая сортировка?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Топологическая сортировка?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Топологическая сортировка на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Топологическая сортировка по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Топологическая сортировка?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "86641297-eb43-4a4e-80f3-b5d0251be51a",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Динамическое программирование: основы?",
        "expected_answer": "Динамическое программирование: основы - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Динамическое программирование: основы?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Динамическое программирование: основы?",
        "expected_answer": "Динамическое программирование: основы применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Динамическое программирование: основы?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Динамическое программирование: основы?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Динамическое программирование: основы?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Динамическое программирование: основы?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Динамическое программирование: основы на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Динамическое программирование: основы по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Динамическое программирование: основы?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "418e64de-c8ec-41c4-8839-305cff460543",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Задача о рюкзаке?",
        "expected_answer": "Задача о рюкзаке - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Задача о рюкзаке?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Задача о рюкзаке?",
        "expected_answer": "Задача о рюкзаке применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Задача о рюкзаке?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Задача о рюкзаке?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Задача о рюкзаке?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Задача о рюкзаке?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Задача о рюкзаке на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Задача о рюкзаке по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Задача о рюкзаке?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "8c3b3fad-390c-4544-a425-2e4b95975ade",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Наибольшая общая подпоследовательность?",
        "expected_answer": "Наибольшая общая подпоследовательность - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Наибольшая общая подпоследовательность?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Наибольшая общая подпоследовательность?",
        "expected_answer": "Наибольшая общая подпоследовательность применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Наибольшая общая подпоследовательность?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Наибольшая общая подпоследовательность?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Наибольшая общая подпоследовательность?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Наибольшая общая подпоследовательность?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Наибольшая общая подпоследовательность на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Наибольшая общая подпоследовательность по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Наибольшая общая подпоследовательность?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "452a69fa-8b53-4904-b6c0-d00a6a4f69c7",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Наибольшая возрастающая подпоследовательность - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Наибольшая возрастающая подпоследовательность применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Наибольшая возрастающая подпоследовательность на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Наибольшая возрастающая подпоследовательность по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Наибольшая возрастающая подпоследовательность?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "b63317ed-f259-4d55-95c6-5ffb63954d9f",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Задача о разрезании стержня?",
        "expected_answer": "Задача о разрезании стержня - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Задача о разрезании стержня?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Задача о разрезании стержня?",
        "expected_answer": "Задача о разрезании стержня применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Задача о разрезании стержня?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Задача о разрезании стержня?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Задача о разрезании стержня?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Задача о разрезании стержня?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Задача о разрезании стержня на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Задача о разрезании стержня по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Задача о разрезании стержня?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "c7459175-ca70-49af-9313-9b984b7d66b5",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Жадные алгоритмы?",
        "expected_answer": "Жадные алгоритмы - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Жадные алгоритмы?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Жадные алгоритмы?",
        "expected_answer": "Жадные алгоритмы применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Жадные алгоритмы?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Жадные алгоритмы?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Жадные алгоритмы?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Жадные алгоритмы?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Жадные алгоритмы на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Жадные алгоритмы по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Жадные алгоритмы?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "3f920330-58dd-4c5f-b2a4-8c34a109af6e",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Задача о размене монет?",
        "expected_answer": "Задача о размене монет - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Задача о размене монет?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Задача о размене монет?",
        "expected_answer": "Задача о размене монет применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Задача о размене монет?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Задача о размене монет?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Задача о размене монет?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Задача о размене монет?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Задача о размене монет на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Задача о размене монет по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Задача о размене монет?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "168b47c6-b921-44be-9404-592720a72fb3",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Задача коммивояжёра?",
        "expected_answer": "Задача коммивояжёра - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Задача коммивояжёра?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Задача коммивояжёра?",
        "expected_answer": "Задача коммивояжёра применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Задача коммивояжёра?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Задача коммивояжёра?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Задача коммивояжёра?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Задача коммивояжёра?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Задача коммивояжёра на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Задача коммивояжёра по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Задача коммивояжёра?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "3933d079-ed57-429c-bb60-13c025cd45a5",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Рекурсия?",
        "expected_answer": "Рекурсия - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Рекурсия?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Рекурсия?",
        "expected_answer": "Рекурсия применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Рекурсия?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Рекурсия?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Рекурсия?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Рекурсия?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Рекурсия на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Рекурсия по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Рекурсия?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "0c0cfb18-4e18-4f82-a378-427566f9e87a",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Деревья отрезков?",
        "expected_answer": "Деревья отрезков - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Деревья отрезков?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Деревья отрезков?",
        "expected_answer": "Деревья отрезков применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Деревья отрезков?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Деревья отрезков?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Деревья отрезков?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Деревья отрезков?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Деревья отрезков на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Деревья отрезков по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Деревья отрезков?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "5957b9c7-53be-4fe7-8325-5e028766812d",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Префиксные суммы?",
        "expected_answer": "Префиксные суммы - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Префиксные суммы?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Префиксные суммы?",
        "expected_answer": "Префиксные суммы применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Префиксные суммы?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Префиксные суммы?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Префиксные суммы?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Префиксные суммы?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Префиксные суммы на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Префиксные суммы по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Префиксные суммы?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "75ec34bd-33a3-4671-ab9f-0be6e9711cf6",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Бинарное дерево поиска?",
        "expected_answer": "Бинарное дерево поиска - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Бинарное дерево поиска?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Бинарное дерево поиска?",
        "expected_answer": "Бинарное дерево поиска применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Бинарное дерево поиска?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Бинарное дерево поиска?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Бинарное дерево поиска?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Бинарное дерево поиска?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Бинарное дерево поиска на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Бинарное дерево поиска по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Бинарное дерево поиска?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "046fbb11-452e-4cb3-8642-6474f8cd0f70",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Префиксное дерево (Trie)?",
        "expected_answer": "Префиксное дерево (Trie) - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Префиксное дерево (Trie)?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Префиксное дерево (Trie)?",
        "expected_answer": "Префиксное дерево (Trie) применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Префиксное дерево (Trie)?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Префиксное дерево (Trie)?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Префиксное дерево (Trie)?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Префиксное дерево (Trie)?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Префиксное дерево (Trie) на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Префиксное дерево (Trie) по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Префиксное дерево (Trie)?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "652dce0b-56ee-4a59-bed5-8024bdb9b2b1",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Алгоритм КМП?",
        "expected_answer": "Алгоритм КМП - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Алгоритм КМП?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Алгоритм КМП?",
        "expected_answer": "Алгоритм КМП применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Алгоритм КМП?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Алгоритм КМП?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Алгоритм КМП?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Алгоритм КМП?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Алгоритм КМП на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Алгоритм КМП по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Алгоритм КМП?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "046c468e-f907-4613-b98a-fe89d9cb735c",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Алгоритм Рабина-Карпа?",
        "expected_answer": "Алгоритм Рабина-Карпа - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Алгоритм Рабина-Карпа?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Алгоритм Рабина-Карпа?",
        "expected_answer": "Алгоритм Рабина-Карпа применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Алгоритм Рабина-Карпа?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Алгоритм Рабина-Карпа?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Алгоритм Рабина-Карпа?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Алгоритм Рабина-Карпа?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Алгоритм Рабина-Карпа на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Алгоритм Рабина-Карпа по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Алгоритм Рабина-Карпа?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "1a595e95-4d82-4ded-8e53-483b826b621d",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Битовые операции?",
        "expected_answer": "Битовые операции - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Битовые операции?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Битовые операции?",
        "expected_answer": "Битовые операции применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Битовые операции?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Битовые операции?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Битовые операции?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Битовые операции?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Битовые операции на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Битовые операции по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Битовые операции?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "9a0eb1c4-260f-4b8c-b1e9-34d050e0fad4",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Анализ сложности алгоритмов?",
        "expected_answer": "Анализ сложности алгоритмов - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Анализ сложности алгоритмов?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Анализ сложности алгоритмов?",
        "expected_answer": "Анализ сложности алгоритмов применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Анализ сложности алгоритмов?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Анализ сложности алгоритмов?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Анализ сложности алгоритмов?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Анализ сложности алгоритмов?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Анализ сложности алгоритмов на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Анализ сложности алгоритмов по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Анализ сложности алгоритмов?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "91b00562-8c9d-438e-b453-b3710664ffe7",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Амортизационный анализ?",
        "expected_answer": "Амортизационный анализ - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Амортизационный анализ?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Амортизационный анализ?",
        "expected_answer": "Амортизационный анализ применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Амортизационный анализ?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Амортизационный анализ?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Амортизационный анализ?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Амортизационный анализ?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Амортизационный анализ на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Амортизационный анализ по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Амортизационный анализ?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "f3af1532-26d5-429f-82d9-63c730421dc2",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Разделяй и властвуй?",
        "expected_answer": "Разделяй и властвуй - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Разделяй и властвуй?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Разделяй и властвуй?",
        "expected_answer": "Разделяй и властвуй применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Разделяй и властвуй?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Разделяй и властвуй?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Разделяй и властвуй?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Разделяй и властвуй?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Разделяй и властвуй на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Разделяй и властвуй по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Разделяй и властвуй?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "2e33e29b-abbc-4d72-a4d7-5e7b23e0a22d",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Метод двух указателей?",
        "expected_answer": "Метод двух указателей - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Метод двух указателей?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Метод двух указателей?",
        "expected_answer": "Метод двух указателей применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Метод двух указателей?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Метод двух указателей?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Метод двух указателей?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Метод двух указателей?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Метод двух указателей на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Метод двух указателей по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Метод двух указателей?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "fc1707fc-a8f9-4ed4-9ddf-1f5ca7925998",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Скользящее окно?",
        "expected_answer": "Скользящее окно - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Скользящее окно?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Скользящее окно?",
        "expected_answer": "Скользящее окно применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Скользящее окно?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Скользящее окно?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Скользящее окно?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Скользящее окно?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Скользящее окно на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Скользящее окно по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Скользящее окно?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "687cefdd-7475-4973-aded-c7c3bd356c63",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Множества?",
        "expected_answer": "Множества - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Множества?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Множества?",
        "expected_answer": "Множества применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Множества?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Множества?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Множества?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Множества?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Множества на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Множества по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Множества?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  },
  {
    "test_id": "f70c42f1-ee94-4135-9b79-65b9d3baf701",
    "questions": [
      {
        "question_id": 1,
        "question_text": "Что такое Словари?",
        "expected_answer": "Словари - это структура/алгоритм в информатике, используемая для эффективной работы с данными",
        "key_points": [
          "Определение",
          "Назначение",
          "Применение"
        ]
      },
      {
        "question_id": 2,
        "question_text": "Какова временная сложность основных операций в Словари?",
        "expected_answer": "Зависит от конкретной реализации, обычно варьируется от O(1) до O(n) или O(log n)",
        "key_points": [
          "Временная сложность",
          "Анализ производительности",
          "Big O нотация"
        ]
      },
      {
        "question_id": 3,
        "question_text": "В каких задачах применяется Словари?",
        "expected_answer": "Словари применяется в различных алгоритмических задачах для оптимизации работы с данными",
        "key_points": [
          "Практическое применение",
          "Задачи",
          "Оптимизация"
        ]
      },
      {
        "question_id": 4,
        "question_text": "Какова пространственная сложность Словари?",
        "expected_answer": "Обычно O(n), где n - количество элементов",
        "key_points": [
          "Память",
          "Пространственная сложность",
          "Расход ресурсов"
        ]
      },
      {
        "question_id": 5,
        "question_text": "Какие преимущества дает использование Словари?",
        "expected_answer": "Эффективность операций, оптимальное использование памяти, решение специфических задач",
        "key_points": [
          "Преимущества",
          "Эффективность",
          "Оптимизация"
        ]
      },
      {
        "question_id": 6,
        "question_text": "Есть ли недостатки у Словари?",
        "expected_answer": "Сложность реализации, возможные ограничения производительности в определенных случаях",
        "key_points": [
          "Недостатки",
          "Ограничения",
          "Компромиссы"
        ]
      },
      {
        "question_id": 7,
        "question_text": "Какие альтернативы существуют для Словари?",
        "expected_answer": "Существуют другие структуры данных и алгоритмы с похожими свойствами",
        "key_points": [
          "Альтернативы",
          "Другие подходы",
          "Сравнение"
        ]
      },
      {
        "question_id": 8,
        "question_text": "Как реализовать Словари на практике?",
        "expected_answer": "Требуется понимание базовых структур данных и алгоритмов",
        "key_points": [
          "Реализация",
          "Практика",
          "Код"
        ]
      },
      {
        "question_id": 9,
        "question_text": "В чем особенность Словари по сравнению с аналогами?",
        "expected_answer": "Уникальные свойства, специфические операции, особые случаи применения",
        "key_points": [
          "Уникальность",
          "Особенности",
          "Отличия"
        ]
      },
      {
        "question_id": 10,
        "question_text": "Какие оптимизации возможны для Словари?",
        "expected_answer": "Зависит от конкретной реализации и требований задачи",
        "key_points": [
          "Оптимизации",
          "Улучшения",
          "Тюнинг"
        ]
      }
    ],
    "expected_duration": 50
  }
]
