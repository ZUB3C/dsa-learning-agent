{
  "creation_date": "2025-12-14",
  "total_questions": 20,
  "topics_count": 2,
  "topics": [
    {
      "topic_id": "topic_1",
      "topic_name": "Сложность алгоритмов и Big O",
      "questions": [
        {
          "question_id": 1,
          "difficulty": "easy",
          "question_text": "Какова временная сложность бинарного поиска в отсортированном массиве из n элементов?",
          "expected_answer": "Временная сложность бинарного поиска составляет O(log n), где n — количество элементов в массиве. На каждом шаге алгоритм делит пространство поиска пополам, что приводит к логарифмической сложности. При каждой итерации размер области поиска уменьшается вдвое, поэтому для массива из 1000 элементов потребуется около 10 сравнений.",
          "user_answer": "O(log n), потому что на каждом шаге массив делится пополам и область поиска уменьшается.",
          "key_points": [
            "O(log n)",
            "Деление пространства поиска пополам",
            "Логарифмическая зависимость от размера",
            "Уменьшение области поиска в 2 раза на каждом шаге"
          ],
          "is_correct": true
        },
        {
          "question_id": 2,
          "difficulty": "easy",
          "question_text": "Что означает нотация O(1) для алгоритма?",
          "expected_answer": "Нотация O(1) означает константную временную сложность. Это значит, что время выполнения алгоритма не зависит от размера входных данных и остается постоянным. Примеры операций с O(1): доступ к элементу массива по индексу, вставка в начало связного списка при наличии указателя на голову.",
          "user_answer": "Это когда алгоритм выполняется очень быстро за одну операцию.",
          "key_points": [
            "Константная временная сложность",
            "Не зависит от размера входных данных",
            "Время выполнения постоянно",
            "Примеры: доступ по индексу, операции со стеком"
          ],
          "is_correct": false
        },
        {
          "question_id": 3,
          "difficulty": "easy",
          "question_text": "Какова временная сложность линейного поиска элемента в неотсортированном массиве?",
          "expected_answer": "Временная сложность линейного поиска составляет O(n), где n — количество элементов в массиве. В худшем случае алгоритм должен проверить каждый элемент массива, чтобы найти искомое значение или убедиться в его отсутствии. В среднем случае сложность также остается O(n).",
          "user_answer": "O(n), так как нужно проверить все элементы массива в худшем случае.",
          "key_points": [
            "O(n)",
            "Проверка каждого элемента",
            "Худший случай — элемент в конце или отсутствует",
            "Линейная зависимость от размера"
          ],
          "is_correct": true
        },
        {
          "question_id": 4,
          "difficulty": "medium",
          "question_text": "Какова временная сложность алгоритма быстрой сортировки (quicksort) в среднем и худшем случае?",
          "expected_answer": "Временная сложность быстрой сортировки в среднем случае составляет O(n log n), где алгоритм эффективно разделяет массив на подзадачи. В худшем случае, когда каждый раз выбирается наихудший опорный элемент (например, в уже отсортированном массиве), сложность составляет O(n²). Худший случай можно избежать, используя рандомизированный выбор опорного элемента.",
          "user_answer": "В среднем O(n log n), в худшем O(n²). Худший случай возникает при плохом выборе pivot элемента.",
          "key_points": [
            "Средний случай: O(n log n)",
            "Худший случай: O(n²)",
            "Худший случай при неудачном выборе опорного элемента",
            "Возможна рандомизация для улучшения"
          ],
          "is_correct": true
        },
        {
          "question_id": 5,
          "difficulty": "medium",
          "question_text": "Что означает квадратичная временная сложность O(n²) и приведите пример алгоритма с такой сложностью?",
          "expected_answer": "Квадратичная временная сложность O(n²) означает, что время выполнения алгоритма растет пропорционально квадрату размера входных данных. Если размер входных данных удваивается, время выполнения увеличивается в 4 раза. Примеры алгоритмов: пузырьковая сортировка, сортировка вставками, сортировка выбором, наивный алгоритм проверки всех пар элементов.",
          "user_answer": "Это когда есть вложенные циклы, которые оба проходят по массиву. Например, bubble sort.",
          "key_points": [
            "Время растет пропорционально квадрату размера",
            "Удвоение данных = учетверение времени",
            "Примеры: пузырьковая, сортировка вставками/выбором",
            "Часто связано с вложенными циклами"
          ],
          "is_correct": true
        },
        {
          "question_id": 6,
          "difficulty": "medium",
          "question_text": "Какова временная сложность сортировки слиянием (merge sort)?",
          "expected_answer": "Временная сложность сортировки слиянием составляет O(n log n) как в среднем, так и в худшем случае. Алгоритм рекурсивно делит массив пополам (log n уровней) и затем сливает отсортированные части (n операций на каждом уровне). Это делает merge sort стабильным алгоритмом с предсказуемой производительностью.",
          "user_answer": "O(n log n) во всех случаях, потому что алгоритм всегда делит массив пополам.",
          "key_points": [
            "O(n log n) в любом случае",
            "Рекурсивное деление пополам (log n уровней)",
            "Слияние на каждом уровне (n операций)",
            "Стабильная сложность"
          ],
          "is_correct": true
        },
        {
          "question_id": 7,
          "difficulty": "medium",
          "question_text": "Что такое пространственная сложность алгоритма и чем она отличается от временной?",
          "expected_answer": "Пространственная сложность алгоритма измеряет объем дополнительной памяти, которую использует алгоритм в зависимости от размера входных данных. В отличие от временной сложности, которая оценивает количество операций, пространственная сложность оценивает потребление памяти. Учитываются переменные, структуры данных, стек вызовов рекурсивных функций.",
          "user_answer": "Это сколько памяти нужно алгоритму, а временная — сколько времени. Например, рекурсивные функции используют много памяти для стека.",
          "key_points": [
            "Измеряет объем дополнительной памяти",
            "Отличие от временной: память vs операции",
            "Учитывает переменные, структуры, стек вызовов",
            "Зависит от размера входных данных"
          ],
          "is_correct": true
        },
        {
          "question_id": 8,
          "difficulty": "medium",
          "question_text": "Какова временная сложность операции вставки элемента в середину обычного массива?",
          "expected_answer": "Временная сложность вставки элемента в середину массива составляет O(n), где n — количество элементов. Это связано с необходимостью сдвинуть все элементы после места вставки на одну позицию вправо. В среднем придется сдвинуть n/2 элементов, что дает линейную сложность O(n).",
          "user_answer": "O(1), потому что мы просто вставляем элемент в нужную позицию.",
          "key_points": [
            "O(n)",
            "Необходимость сдвига элементов вправо",
            "В среднем сдвиг n/2 элементов",
            "Линейная зависимость от размера"
          ],
          "is_correct": false
        },
        {
          "question_id": 9,
          "difficulty": "hard",
          "question_text": "Объясните, почему амортизированная сложность операции добавления элемента в динамический массив (например, ArrayList в Java) составляет O(1), хотя иногда требуется перевыделение памяти?",
          "expected_answer": "Амортизированная сложность добавления элемента O(1) достигается за счет стратегии удвоения размера массива. Когда массив заполняется, его размер увеличивается в 2 раза, и все элементы копируются в новый массив. Эта операция имеет сложность O(n), но происходит редко. Если анализировать последовательность из n операций вставки, суммарная стоимость составит O(n), что дает амортизированную стоимость O(1) на одну операцию.",
          "user_answer": "Потому что перераспределение памяти происходит редко, обычно мы просто добавляем элемент за O(1).",
          "key_points": [
            "Стратегия удвоения размера массива",
            "Редкие дорогие операции O(n)",
            "Анализ последовательности n операций",
            "Суммарная стоимость O(n) для n операций",
            "Амортизированная стоимость O(1) на операцию"
          ],
          "is_correct": false
        },
        {
          "question_id": 10,
          "difficulty": "hard",
          "question_text": "Какова временная сложность алгоритма Дейкстры для поиска кратчайшего пути в графе с использованием приоритетной очереди на основе бинарной кучи?",
          "expected_answer": "Временная сложность алгоритма Дейкстры с приоритетной очередью на бинарной куче составляет O((V + E) log V), где V — количество вершин, E — количество ребер. Каждая вершина извлекается из очереди один раз (V операций по log V), и для каждого ребра выполняется операция уменьшения ключа (E операций по log V). Это значительно эффективнее наивной реализации с O(V²).",
          "user_answer": "O((V + E) log V), где V это вершины, E это ребра. Используется бинарная куча для приоритетной очереди.",
          "key_points": [
            "O((V + E) log V)",
            "V операций извлечения из кучи по log V",
            "E операций уменьшения ключа по log V",
            "Использование бинарной кучи",
            "Эффективнее наивной реализации O(V²)"
          ],
          "is_correct": true
        }
      ]
    },
    {
      "topic_id": "topic_2",
      "topic_name": "Деревья и сбалансированные структуры данных",
      "questions": [
        {
          "question_id": 11,
          "difficulty": "easy",
          "question_text": "Что такое бинарное дерево поиска (BST) и какое основное свойство оно должно поддерживать?",
          "expected_answer": "Бинарное дерево поиска (BST) — это дерево, в котором каждый узел имеет не более двух потомков. Основное свойство: для каждого узла все значения в левом поддереве меньше значения узла, а все значения в правом поддереве больше значения узла. Это свойство позволяет эффективно выполнять операции поиска, вставки и удаления.",
          "user_answer": "BST это дерево где у каждого узла максимум два ребенка, и левый меньше родителя, а правый больше.",
          "key_points": [
            "Каждый узел имеет не более двух потомков",
            "Левое поддерево < узел",
            "Правое поддерево > узел",
            "Свойство для всех узлов дерева"
          ],
          "is_correct": true
        },
        {
          "question_id": 12,
          "difficulty": "easy",
          "question_text": "Какова временная сложность поиска элемента в сбалансированном бинарном дереве поиска?",
          "expected_answer": "Временная сложность поиска в сбалансированном бинарном дереве поиска составляет O(log n), где n — количество узлов в дереве. Сбалансированность гарантирует, что высота дерева пропорциональна log n, поэтому путь от корня до любого листа проходит через O(log n) узлов.",
          "user_answer": "O(log n) потому что дерево сбалансировано и высота небольшая.",
          "key_points": [
            "O(log n)",
            "Высота пропорциональна log n",
            "Сбалансированность гарантирует эффективность",
            "Путь от корня до листа логарифмический"
          ],
          "is_correct": true
        },
        {
          "question_id": 13,
          "difficulty": "easy",
          "question_text": "Какова временная сложность поиска в несбалансированном (вырожденном) бинарном дереве поиска?",
          "expected_answer": "В несбалансированном или вырожденном бинарном дереве поиска (когда дерево превращается в связный список) временная сложность поиска составляет O(n), где n — количество узлов. Это происходит, когда элементы добавлялись в отсортированном порядке, и каждый узел имеет только одного потомка.",
          "user_answer": "O(log n), как в обычном дереве поиска.",
          "key_points": [
            "O(n) в худшем случае",
            "Дерево вырождается в список",
            "Происходит при вставке в отсортированном порядке",
            "Каждый узел имеет только одного потомка"
          ],
          "is_correct": false
        },
        {
          "question_id": 14,
          "difficulty": "medium",
          "question_text": "Что такое AVL-дерево и какое основное свойство балансировки оно поддерживает?",
          "expected_answer": "AVL-дерево — это самобалансирующееся бинарное дерево поиска, названное по именам изобретателей Адельсона-Вельского и Ландиса. Основное свойство: для каждого узла разница высот его левого и правого поддерева (фактор баланса) не превышает 1. При нарушении этого свойства выполняются повороты для восстановления баланса. Это гарантирует логарифмическую высоту дерева и O(log n) для всех операций.",
          "user_answer": "AVL-дерево это сбалансированное дерево, где левое и правое поддерево каждого узла отличаются по высоте максимум на 1.",
          "key_points": [
            "Самобалансирующееся BST",
            "Разница высот поддеревьев ≤ 1",
            "Фактор баланса проверяется для каждого узла",
            "Повороты для восстановления баланса",
            "Гарантирует O(log n) операции"
          ],
          "is_correct": true
        },
        {
          "question_id": 15,
          "difficulty": "medium",
          "question_text": "Какие типы поворотов используются для балансировки AVL-дерева?",
          "expected_answer": "Для балансировки AVL-дерева используются четыре типа поворотов: одинарный правый поворот (right rotation) для случая left-left, одинарный левый поворот (left rotation) для случая right-right, лево-правый поворот (left-right rotation) для случая left-right и право-левый поворот (right-left rotation) для случая right-left. Выбор поворота зависит от того, в каком поддереве произошло нарушение баланса.",
          "user_answer": "Используются правый и левый повороты, а также двойные повороты для сложных случаев.",
          "key_points": [
            "Четыре типа поворотов",
            "Одинарный правый (left-left)",
            "Одинарный левый (right-right)",
            "Лево-правый и право-левый двойные повороты",
            "Выбор зависит от места нарушения"
          ],
          "is_correct": false
        },
        {
          "question_id": 16,
          "difficulty": "medium",
          "question_text": "Что такое красно-черное дерево и какие основные свойства оно поддерживает?",
          "expected_answer": "Красно-черное дерево — это самобалансирующееся бинарное дерево поиска, где каждый узел имеет цвет (красный или черный). Основные свойства: корень всегда черный, красный узел не может иметь красного родителя, все пути от узла до листьев содержат одинаковое количество черных узлов, листья (NIL) черные. Эти свойства гарантируют, что самый длинный путь не более чем в 2 раза длиннее самого короткого.",
          "user_answer": "Красно-черное дерево это дерево где узлы красные или черные. Корень черный, и два красных узла не могут быть рядом.",
          "key_points": [
            "Самобалансирующееся BST с цветами узлов",
            "Корень черный",
            "Красный узел не имеет красного родителя",
            "Одинаковое количество черных узлов на всех путях",
            "Самый длинный путь ≤ 2× самого короткого"
          ],
          "is_correct": true
        },
        {
          "question_id": 17,
          "difficulty": "medium",
          "question_text": "Опишите три основных способа обхода бинарного дерева.",
          "expected_answer": "Три основных способа обхода: 1) Прямой обход (pre-order) — сначала текущий узел, затем левое поддерево, затем правое. 2) Центрированный обход (in-order) — сначала левое поддерево, затем текущий узел, затем правое; для BST дает отсортированную последовательность. 3) Обратный обход (post-order) — сначала левое поддерево, затем правое, затем текущий узел. Все обходы можно реализовать рекурсивно или итеративно с использованием стека.",
          "user_answer": "Pre-order, in-order и post-order. In-order обходит дерево слева направо и дает отсортированный порядок для BST.",
          "key_points": [
            "Pre-order: узел, левое, правое",
            "In-order: левое, узел, правое (дает сортировку для BST)",
            "Post-order: левое, правое, узел",
            "Можно реализовать рекурсивно или итеративно"
          ],
          "is_correct": true
        },
        {
          "question_id": 18,
          "difficulty": "hard",
          "question_text": "В чем основное отличие между AVL-деревом и красно-черным деревом с точки зрения баланса и производительности операций?",
          "expected_answer": "AVL-деревья более строго сбалансированы (разница высот ≤ 1), что обеспечивает более быстрый поиск, но требует больше поворотов при вставке и удалении. Красно-черные деревья имеют более мягкую балансировку (самый длинный путь ≤ 2× самого короткого), что приводит к более быстрым операциям вставки и удаления, но немного медленнее поиску. В итоге AVL лучше для операций чтения, а красно-черные для операций записи.",
          "user_answer": "AVL деревья более сбалансированы и быстрее ищут, но медленнее вставляют. Красно-черные деревья наоборот — быстрее вставка и удаление.",
          "key_points": [
            "AVL более строгая балансировка (высота ≤ 1)",
            "AVL быстрее поиск, медленнее вставка/удаление",
            "Красно-черные мягче сбалансированы (путь ≤ 2×)",
            "Красно-черные быстрее вставка/удаление, медленнее поиск",
            "Выбор зависит от соотношения операций чтения/записи"
          ],
          "is_correct": true
        },
        {
          "question_id": 19,
          "difficulty": "hard",
          "question_text": "Что такое B-дерево и для каких задач оно оптимально?",
          "expected_answer": "B-дерево — это самобалансирующееся дерево поиска, в котором узлы могут иметь более двух потомков (от t до 2t, где t — минимальная степень). Все листья находятся на одном уровне. B-деревья оптимальны для систем с медленным доступом к памяти, таких как базы данных и файловые системы, так как минимизируют количество обращений к диску за счет хранения множества ключей в одном узле.",
          "user_answer": "B-дерево это дерево где узел может иметь много детей, не только два. Используется в базах данных для индексов.",
          "key_points": [
            "Узлы могут иметь более двух потомков",
            "От t до 2t потомков",
            "Все листья на одном уровне",
            "Оптимально для систем с медленным доступом",
            "Использование в БД и файловых системах",
            "Минимизация обращений к диску"
          ],
          "is_correct": false
        },
        {
          "question_id": 20,
          "difficulty": "hard",
          "question_text": "Объясните, как работает операция удаления узла с двумя потомками в бинарном дереве поиска.",
          "expected_answer": "При удалении узла с двумя потомками нужно найти узел-замену, который сохранит свойство BST. Обычно используется один из двух подходов: 1) находим минимальный элемент в правом поддереве (in-order successor) или 2) находим максимальный элемент в левом поддереве (in-order predecessor). Затем копируем значение найденного узла в удаляемый узел и рекурсивно удаляем узел-замену, который гарантированно имеет не более одного потомка.",
          "user_answer": "Нужно найти минимум в правом поддереве, скопировать его значение в удаляемый узел, и удалить минимальный узел.",
          "key_points": [
            "Нужна замена для сохранения свойства BST",
            "Два варианта: минимум справа или максимум слева",
            "Копирование значения замены",
            "Рекурсивное удаление узла-замены",
            "Узел-замена имеет ≤ 1 потомка"
          ],
          "is_correct": true
        }
      ]
    }
  ]
}
