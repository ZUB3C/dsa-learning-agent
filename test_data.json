{
  "test_collection": {
    "creation_date": "2025-11-02",
    "total_questions": 30,
    "topics_count": 5,
    "tests": [
      {
        "test_id": "ADS_SORT_001",
        "topic": "Алгоритмы сортировки",
        "questions": [
          {
            "question_id": 1,
            "difficulty": "easy",
            "question_text": "Объясните, почему алгоритм сортировки пузырьком (Bubble Sort) неэффективен для больших массивов.",
            "expected_answer": "Bubble Sort неэффективен из-за квадратичной временной сложности O(n²), выполняя множество проходов и сравнений соседних элементов.",
            "user_answer": "Потому что у него сложность O(n²), что очень медленно для больших данных.",
            "key_points": ["Временная сложность O(n²)", "Множественные проходы"]
          },
          {
            "question_id": 2,
            "difficulty": "easy",
            "question_text": "Какая сортировка является стабильной?",
            "expected_answer": "Стабильная сортировка сохраняет относительный порядок элементов с одинаковыми ключами.",
            "user_answer": "Стабильная сортировка - это когда она работает предсказуемо. Например, быстрая сортировка стабильна.",
            "key_points": ["Сохранение порядка", "Одинаковые ключи"]
          },
          {
            "question_id": 3,
            "difficulty": "medium",
            "question_text": "Объясните, почему Merge Sort требует O(n) дополнительной памяти.",
            "expected_answer": "Merge Sort требует O(n) дополнительной памяти для временного массива при слиянии подмассивов.",
            "user_answer": "Потому что на каждом уровне рекурсии создается новый массив для слияния.",
            "key_points": ["Временный массив", "Память O(n)"]
          },
          {
            "question_id": 4,
            "difficulty": "medium",
            "question_text": "Когда Heap Sort предпочтительнее Quick Sort?",
            "expected_answer": "Heap Sort предпочтительнее, когда требуется гарантированная O(n log n) в худшем случае.",
            "user_answer": "Когда нужна гарантированная производительность и не допускается O(n²).",
            "key_points": ["Гарантированная сложность", "Худший случай"]
          },
          {
            "question_id": 5,
            "difficulty": "hard",
            "question_text": "Объясните алгоритм Counting Sort и его применение.",
            "expected_answer": "Counting Sort подсчитывает элементы без сравнения, имеет сложность O(n+k) где k - диапазон.",
            "user_answer": "Это сортировка которая считает элементы. Она работает за линейное время O(n).",
            "key_points": ["Подсчет элементов", "O(n+k)", "Диапазон значений"]
          },
          {
            "question_id": 6,
            "difficulty": "hard",
            "question_text": "Объясните, почему нижняя граница для сортировок сравнением O(n log n).",
            "expected_answer": "Нижняя граница O(n log n) доказывается через дерево решений: n! перестановок требуют log(n!) сравнений.",
            "user_answer": "Потому что есть n! возможных перестановок и нужно их различить через сравнения.",
            "key_points": ["Дерево решений", "n! перестановок"]
          }
        ]
      },
      {
        "test_id": "ADS_TREE_002",
        "topic": "Древовидные структуры данных",
        "questions": [
          {
            "question_id": 7,
            "difficulty": "easy",
            "question_text": "Что такое двоичное дерево поиска (BST)?",
            "expected_answer": "BST - это дерево где для каждого узла все значения слева меньше, а справа больше.",
            "user_answer": "Это дерево где слева маленькие числа, а справа большие.",
            "key_points": ["Упорядоченность", "Левое < корень < правое"]
          },
          {
            "question_id": 8,
            "difficulty": "easy",
            "question_text": "Объясните три основных обхода бинарного дерева.",
            "expected_answer": "Inorder (левый-корень-правый), Preorder (корень-левый-правый), Postorder (левый-правый-корень).",
            "user_answer": "Есть три способа: inorder, preorder и postorder. Inorder дает отсортированный результат.",
            "key_points": ["Inorder", "Preorder", "Postorder"]
          },
          {
            "question_id": 9,
            "difficulty": "medium",
            "question_text": "Что такое AVL-дерево и как оно поддерживает баланс?",
            "expected_answer": "AVL-дерево использует ротации для поддержания баланса, разница высот не более 1.",
            "user_answer": "Это красно-черное дерево которое балансируется через специальные операции.",
            "key_points": ["Балансировка", "Ротации", "Фактор баланса"]
          },
          {
            "question_id": 10,
            "difficulty": "medium",
            "question_text": "Опишите структуру красно-черного дерева.",
            "expected_answer": "RB-дерево - самобалансирующееся BST с цветом узлов и 5 основными свойствами.",
            "user_answer": "Это дерево где узлы раскрашены в красный и черный цвета для баланса.",
            "key_points": ["Цвет узлов", "5 свойств", "Черная высота"]
          },
          {
            "question_id": 11,
            "difficulty": "hard",
            "question_text": "Что такое B-дерево и почему оно эффективно для баз данных?",
            "expected_answer": "B-дерево имеет большой фактор ветвления, малую высоту и минимизирует дисковые операции.",
            "user_answer": "B-дерево очень широкое дерево которое используется в базах данных для быстрого доступа.",
            "key_points": ["Большой фактор", "Малая высота", "Дисковые операции"]
          },
          {
            "question_id": 12,
            "difficulty": "hard",
            "question_text": "Объясните концепцию Splay-дерева.",
            "expected_answer": "Splay-дерево перемещает часто используемые узлы в корень через splay-операции (zig, zig-zig, zig-zag).",
            "user_answer": "Это самонастраивающееся дерево которое меняет свою структуру при доступе.",
            "key_points": ["Самонастраивающееся", "Splay-операция", "Часто используемые узлы"]
          }
        ]
      },
      {
        "test_id": "ADS_GRAPH_003",
        "topic": "Алгоритмы на графах",
        "questions": [
          {
            "question_id": 13,
            "difficulty": "easy",
            "question_text": "В чем разница между списком смежности и матрицей смежности?",
            "expected_answer": "Матрица требует O(n²) памяти, список - O(n+m). Матрица быстрее для проверки ребра O(1).",
            "user_answer": "Матрица смежности - это таблица, список - это list структура. Список экономнее по памяти.",
            "key_points": ["Память", "Проверка ребра", "Плотный/разреженный граф"]
          },
          {
            "question_id": 14,
            "difficulty": "easy",
            "question_text": "Что такое DFS и BFS?",
            "expected_answer": "DFS - поиск в глубину (стек), BFS - поиск в ширину (очередь). BFS находит кратчайший путь.",
            "user_answer": "DFS - это рекурсивный поиск, BFS - поиск по уровням. Оба за O(n+m).",
            "key_points": ["Стек/очередь", "Кратчайший путь", "O(n+m)"]
          },
          {
            "question_id": 15,
            "difficulty": "medium",
            "question_text": "Что такое топологическая сортировка?",
            "expected_answer": "Линейное упорядочивание вершин DAG где каждое ребро (u,v) имеет u перед v.",
            "user_answer": "Это сортировка вершин графа который не имеет циклов, для разрешения зависимостей.",
            "key_points": ["DAG", "Зависимости", "DFS/Kahn"]
          },
          {
            "question_id": 16,
            "difficulty": "medium",
            "question_text": "Объясните алгоритм Дейкстры.",
            "expected_answer": "Дейкстра находит кратчайшие пути от одной вершины, используя приоритетную очередь, работает за O((n+m) log n).",
            "user_answer": "Это алгоритм поиска кратчайшего пути который работает за почти линейное время с кучей.",
            "key_points": ["Кратчайшие пути", "Приоритетная очередь", "Неотрицательные веса"]
          },
          {
            "question_id": 17,
            "difficulty": "hard",
            "question_text": "Опишите алгоритм Беллмана-Форда.",
            "expected_answer": "Беллман-Форд находит кратчайшие пути за O(nm), работает с отрицательными весами, обнаруживает отрицательные циклы.",
            "user_answer": "Это алгоритм который релаксирует ребра n-1 раз и может работать с отрицательными весами.",
            "key_points": ["O(nm)", "Отрицательные веса", "Отрицательные циклы"]
          },
          {
            "question_id": 18,
            "difficulty": "hard",
            "question_text": "Объясните теорему о максимальном потоке и минимальном разрезе.",
            "expected_answer": "Значение максимального потока равно пропускной способности минимального разреза.",
            "user_answer": "Максимальный поток это сколько жидкости может пройти от источника к стоку.",
            "key_points": ["Max-flow", "Min-cut", "Равенство"]
          }
        ]
      },
      {
        "test_id": "ADS_HASH_004",
        "topic": "Хеширование и хеш-таблицы",
        "questions": [
          {
            "question_id": 19,
            "difficulty": "easy",
            "question_text": "Что такое хеш-функция?",
            "expected_answer": "Хеш-функция отображает данные произвольного размера на фиксированный размер индекса за O(1).",
            "user_answer": "Это функция которая преобразует ключ в индекс массива для быстрого поиска.",
            "key_points": ["Отображение", "Индекс", "O(1)"]
          },
          {
            "question_id": 20,
            "difficulty": "easy",
            "question_text": "Как решить проблему коллизий в хеш-таблице?",
            "expected_answer": "Методы: цепочки (связные списки), открытая адресация (линейное/квадратичное зондирование, двойное хеширование).",
            "user_answer": "Можно использовать связные списки при коллизии или переместить элемент в другую позицию.",
            "key_points": ["Цепочки", "Открытая адресация", "Линейное/квадратичное зондирование"]
          },
          {
            "question_id": 21,
            "difficulty": "medium",
            "question_text": "Что такое коэффициент загрузки и как он влияет на производительность?",
            "expected_answer": "Коэффициент загрузки α = n/m (элементы/размер). При α > 0.7 обычно требуется rehashing.",
            "user_answer": "Это отношение количества элементов к размеру таблицы, влияет на частоту коллизий.",
            "key_points": ["α = n/m", "Коллизии", "Rehashing"]
          },
          {
            "question_id": 22,
            "difficulty": "medium",
            "question_text": "Объясните концепцию универсального хеширования.",
            "expected_answer": "Универсальное хеширование - случайный выбор хеш-функции из семейства для защиты от худшего случая.",
            "user_answer": "Это когда функция выбирается случайно для снижения вероятности коллизий.",
            "key_points": ["Случайный выбор", "Семейство функций", "Вероятность"]
          },
          {
            "question_id": 23,
            "difficulty": "hard",
            "question_text": "Что такое Robin Hood хеширование?",
            "expected_answer": "Robin Hood - метод, где при вставке элемент может вытеснить другой если его расстояние меньше.",
            "user_answer": "Это специальный метод разрешения коллизий который балансирует расстояния элементов.",
            "key_points": ["Перемещение", "Расстояние", "Балансировка"]
          },
          {
            "question_id": 24,
            "difficulty": "hard",
            "question_text": "Опишите хеш-таблицы с динамическим изменением размера.",
            "expected_answer": "При превышении коэффициента загрузки создается новая таблица большего размера и перехешируются все элементы.",
            "user_answer": "Когда таблица переполняется, создается новая большего размера и все элементы перезаписываются.",
            "key_points": ["Расширение", "Rehashing", "Коэффициент загрузки"]
          }
        ]
      },
      {
        "test_id": "ADS_MISC_005",
        "topic": "Продвинутые техники и оптимизации",
        "questions": [
          {
            "question_id": 25,
            "difficulty": "easy",
            "question_text": "Что такое динамическое программирование?",
            "expected_answer": "DP решает задачи рекурсивно разбивая их на подзадачи и сохраняя результаты для переиспользования.",
            "user_answer": "Это техника когда мы запоминаем результаты подзадач чтобы не считать их снова.",
            "key_points": ["Подзадачи", "Мемоизация", "Перекрытие"]
          },
          {
            "question_id": 26,
            "difficulty": "medium",
            "question_text": "Объясните жадный алгоритм (Greedy Algorithm).",
            "expected_answer": "Жадный алгоритм выбирает локально оптимальное решение на каждом шаге, работает для определенных задач.",
            "user_answer": "Это когда на каждом шаге выбираем лучший вариант без обращения назад.",
            "key_points": ["Локально оптимальное", "Каждый шаг", "Не всегда оптимально"]
          },
          {
            "question_id": 27,
            "difficulty": "medium",
            "question_text": "Что такое двоичный поиск и его условия применения?",
            "expected_answer": "Двоичный поиск работает за O(log n) в отсортированном массиве, делит диапазон пополам на каждом шаге.",
            "user_answer": "Это поиск в отсортированном массиве который работает за логарифмическое время.",
            "key_points": ["O(log n)", "Отсортированный", "Деление пополам"]
          },
          {
            "question_id": 28,
            "difficulty": "hard",
            "question_text": "Объясните алгоритм Евклида для НОД.",
            "expected_answer": "НОД(a,b) = НОД(b, a mod b) рекурсивно пока b не станет 0, работает за O(log(min(a,b))).",
            "user_answer": "Это быстрый алгоритм поиска наибольшего общего делителя через остатки.",
            "key_points": ["Рекурсия", "Остаток", "O(log n)"]
          },
          {
            "question_id": 29,
            "difficulty": "hard",
            "question_text": "Что такое амортизированный анализ?",
            "expected_answer": "Амортизированный анализ показывает среднюю стоимость операции за серию операций, даже если некоторые дорогие.",
            "user_answer": "Это анализ когда средняя стоимость меньше чем худший случай для одной операции.",
            "key_points": ["Средняя стоимость", "Серия операций", "Потенциальный метод"]
          },
          {
            "question_id": 30,
            "difficulty": "hard",
            "question_text": "Объясните концепцию Treap (декартово дерево).",
            "expected_answer": "Treap - рандомизированная структура данных объединяющая BST и кучу через декартовы координаты.",
            "user_answer": "Это дерево которое одновременно поддерживает свойство BST и кучи через случайные приоритеты.",
            "key_points": ["BST", "Куча", "Рандомизированное"]
          }
        ]
      }
    ]
  }
}
