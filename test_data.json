{
  "test_collection": {
    "creation_date": "2025-11-04",
    "total_questions": 30,
    "topics_count": 5,
    "tests": [
      {
        "test_id": "ADS_SORT_001",
        "topic": "Алгоритмы сортировки",
        "questions": [
          {
            "question_id": 1,
            "difficulty": "easy",
            "question_text": "Пусть дан массив из n элементов, где первые k элементов уже отсортированы, а остальные n-k элементов случайны. Какой алгоритм сортировки обеспечит наилучшую асимптотическую сложность в данном случае при k ≈ n/2?\n\nA) Timsort с минимальным размером run равным k\nB) Quicksort с медианой трех в качестве опорного элемента\nC) Merge Sort с предварительным пропуском отсортированной части",
            "options": [
              "A) Timsort с минимальным размером run равным k",
              "B) Quicksort с медианой трех в качестве опорного элемента",
              "C) Merge Sort с предварительным пропуском отсортированной части"
            ],
            "expected_answer": "A) Timsort с минимальным размером run равным k",
            "user_answer": "B) Quicksort с медианой трех в качестве опорного элемента",
            "key_points": [
              "Адаптивность к частично отсортированным данным",
              "Timsort оптимален для runs",
              "O(n log(n-k))"
            ],
            "is_correct": false
          },
          {
            "question_id": 2,
            "difficulty": "easy",
            "question_text": "В каком случае алгоритм Introsort переключается с Quicksort на Heapsort?\n\nA) Когда глубина рекурсии превышает 2⌊log₂(n)⌋\nB) Когда размер подмассива становится меньше 16 элементов\nC) Когда обнаружена квадратичная деградация производительности",
            "options": [
              "A) Когда глубина рекурсии превышает 2⌊log₂(n)⌋",
              "B) Когда размер подмассива становится меньше 16 элементов",
              "C) Когда обнаружена квадратичная деградация производительности"
            ],
            "expected_answer": "A) Когда глубина рекурсии превышает 2⌊log₂(n)⌋",
            "user_answer": "A) Когда глубина рекурсии превышает 2⌊log₂(n)⌋",
            "key_points": [
              "Защита от O(n²)",
              "Ограничение глубины",
              "Гибридный подход"
            ],
            "is_correct": true
          },
          {
            "question_id": 3,
            "difficulty": "easy",
            "question_text": "Для сортировки массива из n строк длиной до m символов с использованием Radix Sort, какая будет итоговая сложность при использовании Counting Sort как подпроцедуры?\n\nA) O(m·(n + k)), где k — размер алфавита\nB) O(n·m·log k)\nC) O(m·n·log n)",
            "options": [
              "A) O(m·(n + k)), где k — размер алфавита",
              "B) O(n·m·log k)",
              "C) O(m·n·log n)"
            ],
            "expected_answer": "A) O(m·(n + k)), где k — размер алфавита",
            "user_answer": "C) O(m·n·log n)",
            "key_points": [
              "Radix Sort проходит m раз",
              "Counting Sort за O(n + k)",
              "Линейное время при малом k"
            ],
            "is_correct": false
          },
          {
            "question_id": 4,
            "difficulty": "easy",
            "question_text": "Рассмотрим модификацию Merge Sort, где вместо разделения массива пополам используется разделение в соотношении 1:3. Какова будет асимптотическая сложность?\n\nA) O(n log₄(n))\nB) O(n log₄/₃(n))\nC) O(n log(n))",
            "options": [
              "A) O(n log₄(n))",
              "B) O(n log₄/₃(n))",
              "C) O(n log(n))"
            ],
            "expected_answer": "C) O(n log(n))",
            "user_answer": "C) O(n log(n))",
            "key_points": [
              "Основание логарифма меняется",
              "Но остается O(n log n)",
              "Константа зависит от соотношения"
            ],
            "is_correct": true
          },
          {
            "question_id": 5,
            "difficulty": "easy",
            "question_text": "В алгоритме Samplesort для параллельной сортировки выбираются p-1 разделителей из s случайных элементов (oversampling). При каком минимальном s гарантируется балансировка O(n/p) с высокой вероятностью?\n\nA) s = p·log p\nB) s = p²\nC) s = √(n·p)",
            "options": [
              "A) s = p·log p",
              "B) s = p²",
              "C) s = √(n·p)"
            ],
            "expected_answer": "A) s = p·log p",
            "user_answer": "B) s = p²",
            "key_points": [
              "Oversampling для балансировки",
              "Вероятностный анализ",
              "Теория сортировки сэмплами"
            ],
            "is_correct": false
          },
          {
            "question_id": 6,
            "difficulty": "easy",
            "question_text": "Какое минимальное количество сравнений требуется для сортировки 5 элементов в худшем случае согласно информационно-теоретической нижней границе?\n\nA) 7 сравнений\nB) 8 сравнений\nC) 9 сравнений",
            "options": [
              "A) 7 сравнений",
              "B) 8 сравнений",
              "C) 9 сравнений"
            ],
            "expected_answer": "A) 7 сравнений",
            "user_answer": "A) 7 сравнений",
            "key_points": [
              "⌈log₂(5!)⌉ = ⌈log₂(120)⌉",
              "7 сравнений достаточно",
              "Оптимальная сеть сортировки"
            ],
            "is_correct": true
          }
        ]
      },
      {
        "test_id": "ADS_TREE_002",
        "topic": "Древовидные структуры данных",
        "questions": [
          {
            "question_id": 7,
            "difficulty": "easy",
            "question_text": "В B⁺-дереве порядка m с n ключами, какова гарантированная минимальная заполненность узлов (кроме корня)?\n\nA) ⌈m/2⌉ ключей\nB) ⌈m/2⌉ - 1 ключей\nC) m/2 ключей",
            "options": [
              "A) ⌈m/2⌉ ключей",
              "B) ⌈m/2⌉ - 1 ключей",
              "C) m/2 ключей"
            ],
            "expected_answer": "B) ⌈m/2⌉ - 1 ключей",
            "user_answer": "A) ⌈m/2⌉ ключей",
            "key_points": [
              "Минимальная степень",
              "B-дерево vs B⁺-дерево",
              "Баланс факторинга"
            ],
            "is_correct": false
          },
          {
            "question_id": 8,
            "difficulty": "easy",
            "question_text": "В красно-черном дереве после удаления черного узла с двумя черными потомками NIL, какое максимальное количество ротаций может потребоваться для восстановления свойств?\n\nA) O(1) ротаций\nB) O(log n) ротаций\nC) O(n) ротаций",
            "options": [
              "A) O(1) ротаций",
              "B) O(log n) ротаций",
              "C) O(n) ротаций"
            ],
            "expected_answer": "A) O(1) ротаций",
            "user_answer": "A) O(1) ротаций",
            "key_points": [
              "Максимум 3 ротации",
              "Случаи перекрашивания",
              "Отличие от вставки"
            ],
            "is_correct": true
          },
          {
            "question_id": 9,
            "difficulty": "easy",
            "question_text": "Дерево отрезков (Segment Tree) для массива размера n хранит суммы на отрезках. Сколько узлов требуется для полного представления?\n\nA) 4n узлов\nB) 2n - 1 узлов\nC) n·log n узлов",
            "options": [
              "A) 4n узлов",
              "B) 2n - 1 узлов",
              "C) n·log n узлов"
            ],
            "expected_answer": "A) 4n узлов",
            "user_answer": "B) 2n - 1 узлов",
            "key_points": [
              "Размер массива для хранения",
              "Полное бинарное дерево",
              "Округление до степени 2"
            ],
            "is_correct": false
          },
          {
            "question_id": 10,
            "difficulty": "easy",
            "question_text": "В Splay-дереве операция zig-zig применяется когда узел x и его родитель p являются оба левыми или оба правыми детьми. Какова амортизированная стоимость одной операции splay?\n\nA) O(1)\nB) O(log n)\nC) O(√n)",
            "options": [
              "A) O(1)",
              "B) O(log n)",
              "C) O(√n)"
            ],
            "expected_answer": "B) O(log n)",
            "user_answer": "B) O(log n)",
            "key_points": [
              "Амортизированный анализ",
              "Метод потенциалов",
              "Теорема о балансе"
            ],
            "is_correct": true
          },
          {
            "question_id": 11,
            "difficulty": "easy",
            "question_text": "Link/Cut дерево поддерживает динамическую связность в лесе. Какова амортизированная сложность операции link(u, v)?\n\nA) O(log n)\nB) O(log² n)\nC) O(√n)",
            "options": [
              "A) O(log n)",
              "B) O(log² n)",
              "C) O(√n)"
            ],
            "expected_answer": "A) O(log n)",
            "user_answer": "B) O(log² n)",
            "key_points": [
              "Splay-дерево как основа",
              "Preferred paths",
              "Амортизация через splay"
            ],
            "is_correct": false
          },
          {
            "question_id": 12,
            "difficulty": "easy",
            "question_text": "В дереве Фенвика (Fenwick Tree / BIT) для массива размера n, какое количество бит требуется для представления индекса с максимальным количеством операций обновления?\n\nA) O(log n) бит\nB) O(n) бит\nC) O(1) бит",
            "options": [
              "A) O(log n) бит",
              "B) O(n) бит",
              "C) O(1) бит"
            ],
            "expected_answer": "A) O(log n) бит",
            "user_answer": "A) O(log n) бит",
            "key_points": [
              "Двоичное представление",
              "Младшие биты",
              "Операция lowbit"
            ],
            "is_correct": true
          }
        ]
      },
      {
        "test_id": "ADS_GRAPH_003",
        "topic": "Алгоритмы на графах",
        "questions": [
          {
            "question_id": 13,
            "difficulty": "easy",
            "question_text": "Алгоритм Tarjan для поиска сильно связных компонент использует стек и DFS. Какова сложность алгоритма для графа с n вершинами и m ребрами?\n\nA) O(n + m)\nB) O(n·m)\nC) O(n²)",
            "options": [
              "A) O(n + m)",
              "B) O(n·m)",
              "C) O(n²)"
            ],
            "expected_answer": "A) O(n + m)",
            "user_answer": "A) O(n + m)",
            "key_points": [
              "Один проход DFS",
              "Линейное время",
              "lowlink значения"
            ],
            "is_correct": true
          },
          {
            "question_id": 14,
            "difficulty": "easy",
            "question_text": "В алгоритме A* с эвристикой h(n), для гарантии оптимальности пути h(n) должна быть:\n\nA) Допустимой (не переоценивать)\nB) Монотонной (согласованной)\nC) Оба условия A и B",
            "options": [
              "A) Допустимой (не переоценивать)",
              "B) Монотонной (согласованной)",
              "C) Оба условия A и B"
            ],
            "expected_answer": "C) Оба условия A и B",
            "user_answer": "A) Допустимой (не переоценивать)",
            "key_points": [
              "Допустимость для оптимальности",
              "Монотонность для эффективности",
              "Неравенство треугольника"
            ],
            "is_correct": false
          },
          {
            "question_id": 15,
            "difficulty": "easy",
            "question_text": "Алгоритм Флойда-Уоршелла находит кратчайшие пути между всеми парами вершин за O(n³). Какую дополнительную информацию можно извлечь без увеличения асимптотики?\n\nA) Транзитивное замыкание графа\nB) Минимальное остовное дерево\nC) Эйлеров цикл",
            "options": [
              "A) Транзитивное замыкание графа",
              "B) Минимальное остовное дерево",
              "C) Эйлеров цикл"
            ],
            "expected_answer": "A) Транзитивное замыкание графа",
            "user_answer": "A) Транзитивное замыкание графа",
            "key_points": [
              "Матрица достижимости",
              "Warshall алгоритм",
              "Та же динамика"
            ],
            "is_correct": true
          },
          {
            "question_id": 16,
            "difficulty": "medium",
            "question_text": "В алгоритме максимального потока Диница используется слоистая сеть. Какова его временная сложность для графа с n вершинами и m ребрами?\n\nA) O(n²·m)\nB) O(n·m·log(max_capacity))\nC) O(min(n^(2/3), m^(1/2))·m)",
            "options": [
              "A) O(n²·m)",
              "B) O(n·m·log(max_capacity))",
              "C) O(min(n^(2/3), m^(1/2))·m)"
            ],
            "expected_answer": "A) O(n²·m)",
            "user_answer": "C) O(min(n^(2/3), m^(1/2))·m)",
            "key_points": [
              "Слоистые сети",
              "Блокирующий поток",
              "Улучшение Форда-Фалкерсона"
            ],
            "is_correct": false
          },
          {
            "question_id": 17,
            "difficulty": "medium",
            "question_text": "Алгоритм Edmond's Blossom для максимального паросочетания в общем графе имеет сложность O(n²·m). Что такое 'blossom' в контексте алгоритма?\n\nA) Цикл нечетной длины в augmenting path\nB) Вершина с нечетной степенью\nC) Непаросочетанное ребро",
            "options": [
              "A) Цикл нечетной длины в augmenting path",
              "B) Вершина с нечетной степенью",
              "C) Непаросочетанное ребро"
            ],
            "expected_answer": "A) Цикл нечетной длины в augmenting path",
            "user_answer": "A) Цикл нечетной длины в augmenting path",
            "key_points": [
              "Нечетные циклы",
              "Сжатие в суперузел",
              "Общие графы"
            ],
            "is_correct": true
          },
          {
            "question_id": 18,
            "difficulty": "medium",
            "question_text": "В алгоритме Хирхольцера для поиска Эйлерова цикла, какое условие необходимо для существования цикла в неориентированном графе?\n\nA) Все вершины имеют четную степень и граф связен\nB) Граф является планарным\nC) Количество ребер равно n-1",
            "options": [
              "A) Все вершины имеют четную степень и граф связен",
              "B) Граф является планарным",
              "C) Количество ребер равно n-1"
            ],
            "expected_answer": "A) Все вершины имеют четную степень и граф связен",
            "user_answer": "A) Все вершины имеют четную степень и граф связен",
            "key_points": [
              "Теорема Эйлера",
              "Четная степень",
              "Связность компонент"
            ],
            "is_correct": true
          }
        ]
      },
      {
        "test_id": "ADS_HASH_004",
        "topic": "Хеширование и хеш-таблицы",
        "questions": [
          {
            "question_id": 19,
            "difficulty": "medium",
            "question_text": "Cuckoo hashing использует две хеш-функции h₁ и h₂. Какова ожидаемая сложность операции вставки в худшем случае?\n\nA) O(1) амортизированное\nB) O(log n) гарантированное\nC) O(n) в худшем случае с рехешированием",
            "options": [
              "A) O(1) амортизированное",
              "B) O(log n) гарантированное",
              "C) O(n) в худшем случае с рехешированием"
            ],
            "expected_answer": "A) O(1) амортизированное",
            "user_answer": "C) O(n) в худшем случае с рехешированием",
            "key_points": [
              "Вытеснение элементов",
              "Две таблицы",
              "Амортизация"
            ],
            "is_correct": false
          },
          {
            "question_id": 20,
            "difficulty": "medium",
            "question_text": "В Perfect hashing с двухуровневой схемой FKS, если на первом уровне n элементов, сколько памяти требуется во втором уровне в худшем случае?\n\nA) O(n)\nB) O(n²)\nC) O(n·log n)",
            "options": [
              "A) O(n)",
              "B) O(n²)",
              "C) O(n·log n)"
            ],
            "expected_answer": "A) O(n)",
            "user_answer": "A) O(n)",
            "key_points": [
              "Квадратичное пространство на бакет",
              "Но O(n) суммарно",
              "Универсальное хеширование"
            ],
            "is_correct": true
          },
          {
            "question_id": 21,
            "difficulty": "medium",
            "question_text": "Bloom filter с m битами и k хеш-функциями для n элементов имеет вероятность ложного срабатывания. При каком k эта вероятность минимальна?\n\nA) k = (m/n)·ln(2)\nB) k = ln(n)\nC) k = √(m·n)",
            "options": [
              "A) k = (m/n)·ln(2)",
              "B) k = ln(n)",
              "C) k = √(m·n)"
            ],
            "expected_answer": "A) k = (m/n)·ln(2)",
            "user_answer": "B) k = ln(n)",
            "key_points": [
              "Оптимальное количество функций",
              "Минимизация FPR",
              "Производная по k"
            ],
            "is_correct": false
          },
          {
            "question_id": 22,
            "difficulty": "medium",
            "question_text": "Count-Min Sketch с d хеш-функциями и w счетчиков в каждой строке оценивает частоту элемента. Какова гарантия точности оценки?\n\nA) ε = e/w с вероятностью 1 - δ при d = ln(1/δ)\nB) Точная оценка всегда\nC) Ошибка O(√n) с высокой вероятностью",
            "options": [
              "A) ε = e/w с вероятностью 1 - δ при d = ln(1/δ)",
              "B) Точная оценка всегда",
              "C) Ошибка O(√n) с высокой вероятностью"
            ],
            "expected_answer": "A) ε = e/w с вероятностью 1 - δ при d = ln(1/δ)",
            "user_answer": "A) ε = e/w с вероятностью 1 - δ при d = ln(1/δ)",
            "key_points": [
              "Переоценка частоты",
              "Вероятностная гарантия",
              "Параметры ε и δ"
            ],
            "is_correct": true
          },
          {
            "question_id": 23,
            "difficulty": "medium",
            "question_text": "Consistent hashing с виртуальными узлами минимизирует перераспределение при изменении количества серверов. При добавлении нового сервера, какая доля ключей перемещается в среднем?\n\nA) O(1/n), где n — количество серверов\nB) O(k/n), где k — количество ключей\nC) O(log n / n)",
            "options": [
              "A) O(1/n), где n — количество серверов",
              "B) O(k/n), где k — количество ключей",
              "C) O(log n / n)"
            ],
            "expected_answer": "A) O(1/n), где n — количество серверов",
            "user_answer": "A) O(1/n), где n — количество серверов",
            "key_points": [
              "Минимальное перераспределение",
              "1/n ключей в среднем",
              "Виртуальные узлы для баланса"
            ],
            "is_correct": true
          },
          {
            "question_id": 24,
            "difficulty": "medium",
            "question_text": "Хеш-функция Zobrist используется в играх для хеширования позиций. В шахматах с 64 клетками и 12 типами фигур, сколько случайных чисел требуется предварительно сгенерировать?\n\nA) 64 × 12 = 768 чисел\nB) 64 + 12 = 76 чисел\nC) 2^64 чисел",
            "options": [
              "A) 64 × 12 = 768 чисел",
              "B) 64 + 12 = 76 чисел",
              "C) 2^64 чисел"
            ],
            "expected_answer": "A) 64 × 12 = 768 чисел",
            "user_answer": "A) 64 × 12 = 768 чисел",
            "key_points": [
              "Таблица случайных чисел",
              "XOR для обновления",
              "Инкрементальное хеширование"
            ],
            "is_correct": true
          }
        ]
      },
      {
        "test_id": "ADS_MISC_005",
        "topic": "Продвинутые техники и оптимизации",
        "questions": [
          {
            "question_id": 25,
            "difficulty": "medium",
            "question_text": "В задаче о рюкзаке 0-1 с весами w_i и ценностями v_i, FPTAS-алгоритм достигает (1-ε)-приближения за время O(n²/ε). На чем основан этот подход?\n\nA) Масштабирование ценностей и округление\nB) Жадная эвристика с локальным поиском\nC) Рандомизированное округление LP-решения",
            "options": [
              "A) Масштабирование ценностей и округление",
              "B) Жадная эвристика с локальным поиском",
              "C) Рандомизированное округление LP-решения"
            ],
            "expected_answer": "A) Масштабирование ценностей и округление",
            "user_answer": "C) Рандомизированное округление LP-решения",
            "key_points": [
              "Округление ценностей",
              "Псевдополиномиальное DP",
              "Trade-off точность/время"
            ],
            "is_correct": false
          },
          {
            "question_id": 26,
            "difficulty": "hard",
            "question_text": "Алгоритм Manacher для поиска всех палиндромных подстрок работает за O(n). Какая ключевая идея позволяет избежать O(n²)?\n\nA) Использование информации о ранее найденных палиндромах через центр\nB) Хеширование подстрок\nC) Суффиксный массив",
            "options": [
              "A) Использование информации о ранее найденных палиндромах через центр",
              "B) Хеширование подстрок",
              "C) Суффиксный массив"
            ],
            "expected_answer": "A) Использование информации о ранее найденных палиндромах через центр",
            "user_answer": "A) Использование информации о ранее найденных палиндромах через центр",
            "key_points": [
              "Симметрия палиндромов",
              "Расширение от центра",
              "Повторное использование"
            ],
            "is_correct": true
          },
          {
            "question_id": 27,
            "difficulty": "hard",
            "question_text": "Суффиксный автомат для строки длины n имеет максимум сколько состояний?\n\nA) 2n - 1 состояний\nB) n² состояний\nC) O(n·log n) состояний",
            "options": [
              "A) 2n - 1 состояний",
              "B) n² состояний",
              "C) O(n·log n) состояний"
            ],
            "expected_answer": "A) 2n - 1 состояний",
            "user_answer": "B) n² состояний",
            "key_points": [
              "Линейное количество",
              "Минимальный ациклический автомат",
              "Все суффиксы"
            ],
            "is_correct": false
          },
          {
            "question_id": 28,
            "difficulty": "hard",
            "question_text": "Алгоритм Mo для ответов на запросы на отрезке без обновлений сортирует запросы по блокам размера √n. Какова итоговая сложность для q запросов?\n\nA) O((n + q)·√n)\nB) O(q·log n)\nC) O(n·√q)",
            "options": [
              "A) O((n + q)·√n)",
              "B) O(q·log n)",
              "C) O(n·√q)"
            ],
            "expected_answer": "A) O((n + q)·√n)",
            "user_answer": "A) O((n + q)·√n)",
            "key_points": [
              "Декомпозиция на блоки",
              "Оптимальный порядок",
              "Add/Remove операции"
            ],
            "is_correct": true
          },
          {
            "question_id": 29,
            "difficulty": "hard",
            "question_text": "Heavy-Light Decomposition разбивает дерево на тяжелые и легкие пути. Какое максимальное количество легких ребер на пути от корня до листа?\n\nA) O(log n)\nB) O(√n)\nC) O(n)",
            "options": [
              "A) O(log n)",
              "B) O(√n)",
              "C) O(n)"
            ],
            "expected_answer": "A) O(log n)",
            "user_answer": "B) O(√n)",
            "key_points": [
              "Размер поддерева уменьшается вдвое",
              "Логарифм легких ребер",
              "Запросы на путях"
            ],
            "is_correct": false
          },
          {
            "question_id": 30,
            "difficulty": "hard",
            "question_text": "Персистентное дерево отрезков позволяет хранить все версии структуры. Сколько дополнительной памяти требуется на одно обновление?\n\nA) O(log n) узлов\nB) O(n) узлов\nC) O(1) узлов",
            "options": [
              "A) O(log n) узлов",
              "B) O(n) узлов",
              "C) O(1) узлов"
            ],
            "expected_answer": "A) O(log n) узлов",
            "user_answer": "A) O(log n) узлов",
            "key_points": [
              "Копирование пути",
              "Path copying",
              "Версионность через разделение"
            ],
            "is_correct": true
          }
        ]
      }
    ]
  }
}
