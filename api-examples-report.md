# API Endpoints Test Report

Отчет создан: 2025-10-30 04:00:58

---

## Общая статистика

| Метрика | Значение |
|---------|----------|
| Всего тестов | 23 |
| Успешных | 20 ✓ |
| Неудачных | 3 ✗ |
| Успешность | 87.0% |
| Общее время выполнения | 346.76s |

---

## System

### ✓ `GET /health/`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Health check endpoint

**Выходные данные:**
```
{
  "status": "ok",
  "time": "2025-10-30T00:55:12.178078"
}
```

---

## Assessment

### ✓ `POST /api/v1/assessment/start`

**Статус:** SUCCESS  
**Время выполнения:** 0.048s  
**Описание:** Начать первичное тестирование

**Входные данные:**
```
{
  "user_id": "test_user_e6d6fa27"
}
```

**Выходные данные:**
```
{
  "session_id": "1021ab9c-dc98-4a33-9192-cc4afc8798ca",
  "test_questions_count": 15,
  "first_question": {
    "question_id": 1,
    "question_text": "Что такое временная сложность алгоритма?",
    "options": [
      "Время работы программы на конкретном компьютере",
      "Оценка количества операций в зависимости от размера входных данных",
      "Размер памяти, занимаемой программой",
      "Скорость работы процессора"
    ]
  }
}
```

---

### ✓ `POST /api/v1/assessment/submit`

**Статус:** SUCCESS  
**Время выполнения:** 0.014s  
**Описание:** Отправить результаты тестирования

**Входные данные:**
```
{
  "session_id": "1021ab9c-dc98-4a33-9192-cc4afc8798ca",
  "answers": [
    {
      "question_id": 1,
      "answer": 1
    },
    {
      "question_id": 2,
      "answer": 2
    },
    {
      "question_id": 3,
      "answer": 1
    }
  ]
}
```

**Выходные данные:**
```
{
  "level": "beginner",
  "knowledge_areas": {
    "complexity": 100.0
  },
  "recommendations": [
    "Рекомендуется начать с основ: временная и пространственная сложность",
    "Изучите базовые структуры данных: массивы, списки, стеки, очереди",
    "Практикуйтесь в написании простых алгоритмов",
    "Освойте базовые концепции рекурсии"
  ]
}
```

---

### ✓ `GET /api/v1/assessment/results/{user_id}`

**Статус:** SUCCESS  
**Время выполнения:** 0.007s  
**Описание:** Получить результаты начальной оценки

**Входные данные:**
```
{
  "user_id": "test_user_e6d6fa27"
}
```

**Выходные данные:**
```
{
  "message": null,
  "user_id": "test_user_e6d6fa27",
  "initial_level": "beginner",
  "score": 20.0,
  "knowledge_areas": {
    "complexity": 100.0
  },
  "recommendations": [
    "Рекомендуется начать с основ: временная и пространственная сложность",
    "Изучите базовые структуры данных: массивы, списки, стеки, очереди",
    "Практикуйтесь в написании простых алгоритмов",
    "Освойте базовые концепции рекурсии"
  ],
  "completed_at": "2025-10-30T00:55:12.235406"
}
```

---

## Materials

### ✓ `GET /api/v1/materials/topics`

**Статус:** SUCCESS  
**Время выполнения:** 0.005s  
**Описание:** Получить список доступных тем

**Выходные данные:**
```
{
  "predefined_topics_count": 12,
  "custom_topics_count": 8,
  "predefined_topics_preview": [
    "Временная сложность",
    "Пространственная сложность",
    "Массивы"
  ]
}
```

---

### ✓ `POST /api/v1/materials/add-custom-topic`

**Статус:** SUCCESS  
**Время выполнения:** 0.638s  
**Описание:** Добавить пользовательскую тему

**Входные данные:**
```
{
  "topic_name": "Алгоритмы поиска в графах",
  "user_id": "test_user_4be1734b",
  "content": "Изучение алгоритмов BFS, DFS и Dijkstra"
}
```

**Выходные данные:**
```
{
  "topic_id": "custom_2ef94a08-72a4-47e5-8ed5-d187eb0d74be",
  "status": "added"
}
```

---

### ✓ `POST /api/v1/materials/get-materials`

**Статус:** SUCCESS  
**Время выполнения:** 89.426s  
**Описание:** Получить адаптированные учебные материалы

**Входные данные:**
```
{
  "topic": "Сортировка массивов",
  "user_level": "beginner",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "content_preview": "\n### Сортировка массивов для начинающих\n\n**Что такое сортировка?**  \nСортировка — это процесс упорядочивания элементов массива в определённом порядке (например, по возрастанию или убыванию).  \n**Пример из жизни:** Представьте, что вы сортируете книги на полке по алфавиту. Так их легче найти!\n\n---\n\n### Зачем сортировать массивы?\n1. **Ускорение поиска** (например, бинарный поиск работает только на отсортированных данных).\n2. **Анализ данных** (например, найти медиану или минимальное/максимальное значение).\n3. **Удобство для пользователя** (вывод товаров в интернет-магазине по цене).\n\n---\n\n### Основные алгоритмы сортировки (для начинающих)\n\n#### 1. Пузырьковая сортировка (Bubble Sort)\n**Идея:** Сравниваем соседние элементы и меняем их местами, если они стоят в неправильном порядке. Процесс повторяется, пока массив не будет отсортирован.  \n**Пример для массива `[5, 3, 8, 4, 2]`:**  \n- Первый проход: `[3, 5, 4, 2, 8]` (число 8 «всплыло» в конец).  \n- Второй проход: `[3, 4, 2, 5, 8]` (число ...",
  "sources": [
    "algobook.pdf",
    "algobook.pdf",
    "algobook.pdf",
    "algobook.pdf",
    "algobook.pdf"
  ],
  "adapted_for_level": "beginner"
}
```

---

### ✓ `POST /api/v1/materials/generate-material`

**Статус:** SUCCESS  
**Время выполнения:** 35.386s  
**Описание:** Сгенерировать учебный материал

**Входные данные:**
```
{
  "topic": "Бинарный поиск",
  "format": "summary",
  "length": "short",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "material_preview": "# Краткое содержание: Бинарный поиск\n\n\n### Бинарный поиск: объяснение для начинающих\n\n#### Что это?\n**Бинарный поиск** — это алгоритм для быстрого поиска элемента в **отсортированном массиве** (например, в списке чисел, идущих по порядку). Он работает по принципу \"разделяй и властвуй\", постоянно сокращая область поиска вдвое.\n\n#### Как работает?\n1. **Начало**: Определяем границы поиска — левую (`left`) и правую (`right`). В начале это первый и последний элементы массива.\n2. **Середина**: Находим средний элемент (`mid`) между `left` и `right`.\n3. **Сравнение**:\n   - Если `mid` равен искомому элементу — поиск завершен!\n   - Если `mid` меньше искомого — ищем в **правой** половине (сдвигаем `left`).\n   - Если `mid` больше искомого — ищем в **левой** половине (сдвигаем `right`).\n4. **Повторение**: Повторяем шаги 2–3, пока не найдем элемент или не убедимся, что его нет.\n\n#### Пример \"на пальцах\"\nДопустим, у нас есть отсортированный массив:  \n`[2, 5, 8, 12, 16, 23, 38, 56]`.  \nИщем число **23...",
  "format": "summary",
  "word_count": 377,
  "model_used": "GigaChat",
  "topic_id": "generated_ddeb50f2-4c8a-4abc-8545-8169acba0408"
}
```

---

### ✓ `POST /api/v1/materials/ask-question`

**Статус:** SUCCESS  
**Время выполнения:** 51.131s  
**Описание:** Задать вопрос по материалу

**Входные данные:**
```
{
  "question": "Какова временная сложность бинарного поиска?",
  "context_topic": "Бинарный поиск",
  "user_level": "beginner",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "answer": "\n### Бинарный поиск: объяснение для начинающих\n\n#### Что это такое?\n**Бинарный поиск** — это алгоритм для быстрого поиска элемента в **отсортированном массиве**. Он работает за время **O(log n)**, что намного эффективнее линейного поиска (O(n)). \n\n**Ключевое условие:** массив должен быть отсортирован (например, по возрастанию).\n\n---\n\n#### Как это работает? (Аналогия)\nПредставьте, что вы ищете слово в словаре:\n1. Откройте словарь на середине.\n2. Если нужное слово стоит раньше — отбросьте правую половину.\n3. Если позже — отбросьте левую половину.\n4. Повторяйте, пока не найдете слово.\n\nБинарный поиск работает так же, но с числами или данными в массиве!\n\n---\n\n#### Пошаговый алгоритм\n1. **Найдите середину** массива.\n2. **Сравните** элемент в середине с искомым значением:\n   - Если они равны — поиск завершен.\n   - Если искомое значение **меньше** — ищите в **левой** половине.\n   - Если **больше** — в **правой** половине.\n3. **Повторяйте** шаги 1-2 для выбранной половины, пока элемент не будет найден или массив не закончится.\n\n---\n\n#### Пример \"на пальцах\"\n**Массив:** `[2, 5, 8, 12, 16, 23, 38, 45]`  \n**Ищем:** `16`\n\n1. Середина массива — `12` (индекс 3).  \n   `16 > 12` → ищем в правой половине `[16, 23, 38, 45]`.\n2. Середина новой части — `23` (индекс 5).  \n   `16 < 23` → ищем в левой половине `[16]`.\n3. Нашли `16` (индекс 4)!\n\n---\n\n#### Реализация на Python\n```python\ndef binary_search(arr, target):\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2  # Находим середину\n        if arr[mid] == target:\n            return mid  # Элемент найден!\n        elif arr[mid] < target:\n            left = mid + 1  # Ищем в правой половине\n        else:\n            right = mid - 1  # Ищем в левой половине\n    return -1  # Элемент не найден\n\n# Пример использования:\narr = [2, 5, 8, 12, 16, 23, 38, 45]\ntarget = 16\nprint(binary_search(arr, target))  # Вывод: 4 (индекс элемента 16)\n```\n\n---\n\n#### Почему это быстро?\n- На каждом шаге массив **уменьшается вдвое**.  \n- Даже для массива из **1 000 000 элементов** потребуется не более **20 шагов** (log₂(1 000 000) ≈ 20).\n\n---\n\n#### Где используется?\n- Поиск в базах данных.\n- Игры с угадыванием чисел («Загадал число от 1 до 100»).\n- Алгоритмы оптимизации (например, поиск корня уравнения).\n\n---\n\n#### Важные нюансы\n1. **Массив должен быть отсортирован!** Иначе алгоритм не сработает.\n2. **Осторожно с границами:** Если забыть обновлять `left` или `right`, можно попасть в бесконечный цикл.\n3. **Повторяющиеся элементы:** Алгоритм найдет любой из них, но не обязательно первый или последний.\n\n---\n\n#### Итог\nБинарный поиск — ваш лучший друг для работы с **большими отсортированными данными**. Он простой, но невероятно эффективный! Попробуйте реализовать его самостоятельно — это отличная тренировка для понимания алгоритмов.",
  "related_concepts": [
    "Бинарный поиск"
  ]
}
```

---

### ✓ `POST /api/v1/materials/search`

**Статус:** SUCCESS  
**Время выполнения:** 0.057s  
**Описание:** Поиск материалов

**Входные данные:**
```
{
  "query": "Сортировка пузырьком",
  "filters": {
    "level": "beginner"
  }
}
```

**Выходные данные:**
```
{
  "results_count": 0,
  "relevance_scores": []
}
```

---

## Tests

### ✓ `POST /api/v1/tests/generate`

**Статус:** SUCCESS  
**Время выполнения:** 33.081s  
**Описание:** Сгенерировать тест по теме

**Входные данные:**
```
{
  "topic": "Сортировка пузырьком",
  "difficulty": "easy",
  "question_count": 3,
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
  "questions_count": 0,
  "expected_duration": 15,
  "first_question": null
}
```

---

### ✓ `POST /api/v1/tests/generate-task`

**Статус:** SUCCESS  
**Время выполнения:** 33.372s  
**Описание:** Сгенерировать задачу

**Входные данные:**
```
{
  "topic": "Рекурсия",
  "difficulty": "medium",
  "task_type": "coding",
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "task_id": "task_7831391941853739002",
  "description_preview": "Решите задачу по теме 'Рекурсия' уровня сложности 'medium'",
  "hints_count": 2,
  "model_used": "GigaChat"
}
```

---

### ✓ `GET /api/v1/tests/3b76de5e-1c06-40bb-b777-a8d0f7540fab`

**Статус:** SUCCESS  
**Время выполнения:** 0.015s  
**Описание:** Получить тест по ID

**Входные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab"
}
```

**Выходные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
  "topic": "Сортировка пузырьком",
  "difficulty": "easy"
}
```

---

### ✓ `POST /api/v1/tests/submit-for-verification`

**Статус:** SUCCESS  
**Время выполнения:** 0.021s  
**Описание:** Отправить тест на проверку

**Входные данные:**
```
{
  "test_id": "3b76de5e-1c06-40bb-b777-a8d0f7540fab",
  "user_id": "test_user_437aa12e",
  "answers": [
    {
      "question_id": 1,
      "answer": "Тестовый ответ"
    }
  ]
}
```

**Выходные данные:**
```
{
  "verification_id": "f2cf5ba8-f55f-404c-ac02-e893e4f382c0",
  "status": "pending"
}
```

---

### ✓ `GET /api/v1/tests/user/{user_id}/completed`

**Статус:** SUCCESS  
**Время выполнения:** 0.023s  
**Описание:** Получить завершенные тесты пользователя

**Входные данные:**
```
{
  "user_id": "test_user_437aa12e"
}
```

**Выходные данные:**
```
{
  "completed_tests_count": 1,
  "statistics": {
    "total_completed": 1
  }
}
```

---

## Verification

### ✗ `POST /api/v1/verification/check-test`

**Статус:** ERROR  
**Время выполнения:** 17.776s  
**Описание:** Проверка ответа на тест с двойной верификацией

**Входные данные:**
```
{
  "question": "test",
  "user_answer": "test"
}
```

**Ошибка:**


---

### ✗ `POST /api/v1/verification/check-test`

**Статус:** ERROR  
**Время выполнения:** 17.065s  
**Описание:** Проверка ответа на тест с двойной верификацией

**Входные данные:**
```
{
  "question": "test2",
  "user_answer": "test2"
}
```

**Ошибка:**


---

### ✓ `GET /api/v1/verification/history/{user_id}`

**Статус:** SUCCESS  
**Время выполнения:** 0.003s  
**Описание:** Получить историю проверок пользователя

**Входные данные:**
```
{
  "user_id": "test_user_ec5ba6bb"
}
```

**Выходные данные:**
```
{
  "tests_count": 0,
  "warning": "История пуста. Возможно, check-test не связывает данные с user_id."
}
```

**Ошибка:**


---

## LLM Router

### ✓ `GET /api/v1/llm-router/available-models`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Получить список доступных LLM моделей.

**Выходные данные:**
```
{
  "models": [
    {
      "name": "GigaChat",
      "language": "ru",
      "provider": "Sber"
    },
    {
      "name": "DeepSeek",
      "language": "en",
      "provider": "DeepSeek"
    }
  ],
  "capabilities": {
    "material_generation": true,
    "task_generation": true,
    "test_generation": true,
    "question_answering": true
  }
}
```

---

### ✓ `POST /api/v1/llm-router/route-request`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Маршрутизация запроса к подходящей модели.

**Входные данные:**
```
{
  "request_type": "material",
  "content": "Объясни принцип работы хеш-таблиц",
  "context": null,
  "language": "ru"
}
```

**Выходные данные:**
```
{
  "selected_model": "GigaChat",
  "reasoning": "Selected GigaChat for material in ru",
  "confidence": 0.9,
  "alternative_models": []
}
```

---

### ✓ `POST /api/v1/llm-router/select-and-generate`

**Статус:** SUCCESS  
**Время выполнения:** 68.645s  
**Описание:** Выбрать подходящую модель и сгенерировать контент

**Входные данные:**
```
{
  "request_type": "material",
  "content": "Что такое динамическое программирование?",
  "language": "ru",
  "parameters": {}
}
```

**Выходные данные:**
```
{
  "generated_content_preview": "\n### Задача о выборе непересекающихся интервалов (Interval Scheduling)\n\n#### Постановка задачи\nДано множество интервалов на прямой.  \n**Цель:** выбрать максимальное количество непересекающихся интервалов.\n\n**Пример:**  \nИнтервалы могут представлять лекции в аудитории (начало и конец), и нужно разместить как можно больше мероприятий без перекрытий.\n\n---\n\n#### Ключевая идея: жадный алгоритм\nЖадные алгоритмы часто эффективны для задач выбора интервалов. Основная интуиция:\n> **\"Выбирай интервал, который раньше всего заканчивается — это оставит больше места для остальных\"**.\n\n#### Почему сортировка по правому концу?\n1. **Оптимальность:** Сортировка по правому концу гарантирует нахождение максимального числа интервалов.\n2. **Контрпример для других стратегий:**\n   - **Сортировка по левому концу:** Может давать неоптимальный результат.\n   - **Сортировка по длине:** Тоже не гарантирует оптимальности.\n\n**Пример из материалов (Рис. 2.16-2.18):**  \nДопустим, интервалы расположены так:\n```\n1: [1, 4...",
  "model_used": "GigaChat"
}
```

---

## Support

### ✓ `GET /api/v1/support/resources`

**Статус:** SUCCESS  
**Время выполнения:** 0.000s  
**Описание:** Получить ресурсы психологической поддержки

**Выходные данные:**
```
{
  "articles_count": 2,
  "exercises_count": 2,
  "tips_count": 3
}
```

---

### ✗ `POST /api/v1/support/get-support`

**Статус:** ERROR  
**Время выполнения:** 0.000s  
**Описание:** Получить психологическую поддержку

**Входные данные:**
```
{
  "message": "test",
  "emotional_state": "frustrated"
}
```

**Ошибка:**


---

