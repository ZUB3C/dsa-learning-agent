{
  "topic_id": "advanced_01",
  "topic": "Динамическое программирование",
  "user_level": "advanced",
  "success": true,
  "material_length": 3568,
  "word_count": 402,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.7,
  "documents_collected": 10,
  "completeness_score": 0.7,
  "relevance_score": 1.0,
  "quality_score": 0.7,
  "generation_time_seconds": 153.98825025558472,
  "gigachat2_calls": 9,
  "gigachat3_calls": 36,
  "estimated_cost_usd": 0.036,
  "tools_used": [
    "web_search",
    "adaptive_rag_search",
    "corrective_check"
  ],
  "generation_id": "gen_8082d5205a8d",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Динамическое программирование  \n\n## Введение  \n\nДинамическое программирование — мощный метод оптимизации решений задач путём декомпозиции исходной проблемы на серию взаимосвязанных подзадач. Этот подход позволяет эффективно избегать повторного пересчета одних и тех же промежуточных результатов, существенно сокращая вычислительную нагрузку. Метод широко используется в задачах оптимизации, обработки строк, анализа последовательностей и многих других областях.\n\n## Основная теория  \n\n### Суть метода  \nМетод динамического программирования основан на следующих ключевых принципах:  \n\n1. **Выделение подзадач**: Исходная задача разделяется на серию связанных подзадач, каждая из которых решается независимо.  \n2. **Оптимальная подструктура**: Решение каждой подзадачи должно зависеть лишь от решений предыдущих подзадач.  \n3. **Запоминание результатов**: Результаты уже решённых подзадач сохраняются, предотвращая повторные расчёты.  \n4. **Рекуррентные соотношения**: Между результатами подзадач существуют чётко определённые зависимости, выражаемые формулами или функциями.  \n\n### Пример задачи  \nРассмотрим классическую задачу нахождения наибольшей общей подпоследовательности двух строк (`LCS`). Пусть даны строки `X = x₁x₂...xᵢ` и `Y = y₁y₂...yᵤ`. Необходимо определить максимальную длину последовательности символов, встречающуюся одновременно в обеих строках.  \n\n#### Рекуррентное соотношение  \nПусть `dp[i][j]` обозначает длину наибольшей общей подпоследовательности первых i символов X и j символов Y. Тогда:  \n\n$$\ndp[i][j] =\n\\begin{cases}\n0 & \\text{if } i=0 \\text{ or } j=0 \\\\\ndp[i-1][j-1]+1 & \\text{if } x_i=y_j \\\\\n\\max(dp[i-1][j], dp[i][j-1]) & \\text{otherwise}\n\\end{cases}\n$$  \n\n### Реализация на Python  \n```python\ndef lcs(X, Y):\n    m, n = len(X), len(Y)\n    # Создаем таблицу размером (m+1)x(n+1)\n    dp = [[0 for _ in range(n+1)] for __ in range(m+1)]\n    \n    # Заполняем таблицу снизу вверх\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if X[i-1] == Y[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                \n    return dp[m][n]\n```\n\n### Анализ временной и пространственной сложности  \n- Время выполнения: O(m*n), где m и n длины строк соответственно.  \n- Пространственная сложность: O(m*n).\n\n## Практическое применение  \n\n### Примеры реальных задач  \n1. **Поиск оптимального маршрута**: Нахождение кратчайшего пути в транспортной сети.  \n2. **Анализ ДНК-последовательностей**: Поиск сходства между генетическими цепочками.  \n3. **Распознавание образов**: Определение схожих изображений или объектов.  \n\n### Советы по применению  \n- Всегда проверяйте наличие оптимальной подструктуры перед применением динамического программирования.  \n- Используйте двумерные таблицы для хранения промежуточных результатов.  \n- Убедитесь, что размер массива достаточен для хранения всех необходимых значений.  \n\n## Дополнительные ресурсы  \n- [Кормен, Лейзерсон, Ривест, Штайн. Алгоритмы: построение и анализ](https://www.labirint.ru/books/47111/)  \n- [Кнут Дональд Эрвин. Искусство программирования. Том 1: Основные алгоритмы](https://www.ozon.ru/product/iskusstvo-programmirovaniya-tom-1-osnovnye-algoritmy-knut-donald-erwin-13616663/)\n\n## Заключение  \nДинамическое программирование — универсальный инструмент для эффективного решения широкого спектра задач оптимизации. Его правильное применение требует понимания принципов декомпозиции и сохранения промежуточных результатов, что делает его мощным инструментом в арсенале профессионального разработчика."
}