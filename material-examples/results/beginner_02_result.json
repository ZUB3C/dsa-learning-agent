{
  "topic_id": "beginner_02",
  "topic": "Стек как структура данных",
  "user_level": "beginner",
  "success": true,
  "material_length": 6148,
  "word_count": 701,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.7,
  "documents_collected": 7,
  "completeness_score": 0.7,
  "relevance_score": 0.8,
  "quality_score": 0.7,
  "generation_time_seconds": 158.60757207870483,
  "gigachat2_calls": 9,
  "gigachat3_calls": 36,
  "estimated_cost_usd": 0.036,
  "tools_used": [
    "web_search",
    "adaptive_rag_search",
    "corrective_check"
  ],
  "generation_id": "gen_f80c360e5a9f",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Учебный материал по теме: Стек как структура данных  \n\n## Введение  \n\nСтек — одна из базовых структур данных, используемых практически повсеместно в разработке программного обеспечения. Его принцип работы интуитивно понятен каждому человеку благодаря повседневной жизни: вспомните стопку книг или тарелок — последнюю положенную книгу или тарелку вы снимаете первой. Этот же подход лежит в основе стека в информатике.  \n\nПочему изучение стека важно? Потому что эта простая концепция помогает эффективно решать широкий спектр задач программирования, начиная от обработки арифметических выражений и заканчивая управлением памятью и обработкой ошибок. Понимание принципов работы стека позволит вам писать более эффективные и надежные программы.  \n\n## Основная теория  \n\n### Определение стека  \n\nСтек (англ. *stack*) — это структура данных, организованная по принципу **«последним пришел — первым ушел»**, сокращенно обозначаемая как **LIFO (*Last In First Out*)**. Представьте себе стопку монет: монета, положенная сверху, снимается первой. Аналогичным образом работают данные в стеке: последние добавленные элементы извлекаются первыми.  \n\n### Основные операции над стеком  \n\nРассмотрим ключевые операции, поддерживаемые стеком:  \n\n- `push(item)` — добавляет элемент в верхушку стека.  \n- `pop()` — удаляет верхний элемент из стека и возвращает его значение.  \n- `peek()` — возвращает значение верхнего элемента, не удаляя его.  \n- `is_empty()` — проверяет, пустой ли стек.  \n\nЭти операции имеют временную сложность $\\mathcal{O}(1)$, то есть выполняются за константное время независимо от размера стека.  \n\n### Реализация стека  \n\nСуществует несколько способов реализации стека:  \n\n#### 1. На основе массива  \nЭто наиболее простое решение, когда элементы хранятся последовательно в одном массиве. Однако здесь возникает проблема перерастания массива, что усложняет управление памятью.  \n\n```python\nclass StackArray:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, item):\n        \"\"\" Добавляет элемент в стек \"\"\"\n        self.stack.append(item)\n    \n    def pop(self):\n        \"\"\" Удаляет и возвращает верхний элемент \"\"\"\n        if not self.is_empty():\n            return self.stack.pop()\n        else:\n            raise IndexError('Stack is empty')\n    \n    def peek(self):\n        \"\"\" Возвращает верхний элемент без удаления \"\"\"\n        if not self.is_empty():\n            return self.stack[-1]\n        else:\n            raise IndexError('Stack is empty')\n    \n    def is_empty(self):\n        \"\"\" Проверяет, пуст ли стек \"\"\"\n        return len(self.stack) == 0\n```\n\n#### 2. На основе связанного списка  \nЭтот способ предпочтительнее, поскольку связанному списку не нужна предварительная память под весь объем данных. Каждый элемент содержит ссылку на следующий элемент, образуя цепочку.  \n\n```python\nclass Node:\n    def __init__(self, value=None):\n        self.value = value\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.top = None\n    \n    def push(self, item):\n        \"\"\" Добавляет элемент в стек \"\"\"\n        new_node = Node(item)\n        new_node.next = self.top\n        self.top = new_node\n    \n    def pop(self):\n        \"\"\" Удаляет и возвращает верхний элемент \"\"\"\n        if not self.is_empty():\n            popped_value = self.top.value\n            self.top = self.top.next\n            return popped_value\n        else:\n            raise IndexError('Stack is empty')\n    \n    def peek(self):\n        \"\"\" Возвращает верхний элемент без удаления \"\"\"\n        if not self.is_empty():\n            return self.top.value\n        else:\n            raise IndexError('Stack is empty')\n    \n    def is_empty(self):\n        \"\"\" Проверяет, пуст ли стек \"\"\"\n        return self.top is None\n```\n\n### Применение стека  \n\nСтеки используются в различных областях программирования:  \n\n- **Обработка выражений**: проверка правильности расстановки скобок, вычисление постфиксных выражений.  \n- **Алгоритмы обхода графа**: глубина первого поиска (DFS).  \n- **Реализовать историю отмены/повтора**: редакторы текста используют стек для хранения предыдущих состояний документа.  \n- **Управление памятью**: компиляторы и интерпретаторы используют стек для вызова функций и управления локальными переменными.  \n\n## Примеры  \n\n### Пример №1: Разворот строки  \nЗадача: развернуть строку с помощью стека.  \n\n```python\ndef reverse_string(s):\n    stack = []\n    for char in s:\n        stack.append(char)\n    reversed_string = ''\n    while stack:\n        reversed_string += stack.pop()\n    return reversed_string\n\nprint(reverse_string(\"hello\"))  # Выведет 'olleh'\n```\n\n### Пример №2: Проверка сбалансированности скобок  \nЗадача: определить, правильно ли расставлены скобки в строке.  \n\n```python\ndef check_brackets(expression):\n    brackets_map = {'(': ')', '{': '}', '[': ']'}\n    open_brackets = set(brackets_map.keys())\n    close_brackets = set(brackets_map.values())\n    stack = []\n    \n    for char in expression:\n        if char in open_brackets:\n            stack.append(char)\n        elif char in close_brackets:\n            if not stack or brackets_map[stack.pop()] != char:\n                return False\n    return len(stack) == 0\n\nprint(check_brackets(\"{()}[]\"))  # True\nprint(check_brackets(\"[({)]\"))   # False\n```\n\n## Практические советы  \n\n- Всегда проверяйте стек на пустоту перед операциями извлечения (`pop`, `peek`), иначе возможны исключения.  \n- Используйте стек там, где важна последовательность выполнения операций (например, обработка вложенных конструкций).  \n- Помните про ограничения производительности разных реализаций стека (массивы vs списки): выбирайте подходящий вариант исходя из требований вашей задачи.  \n- Не забывайте очищать стек после завершения работы, особенно если речь идет о больших объемах данных.  \n\n## Дополнительные ресурсы  \n\n- [Документация Python](https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-stacks)  \n- Книга: Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ. Глава 10.  \n\nНадеюсь, этот материал поможет вам лучше понять работу стека и применять эту структуру данных в ваших проектах!"
}