{
  "topic_id": "intermediate_05",
  "topic": "Рекурсия и обход дерева",
  "user_level": "intermediate",
  "success": true,
  "material_length": 7584,
  "word_count": 910,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.4,
  "documents_collected": 7,
  "completeness_score": 0.4,
  "relevance_score": 0.5,
  "quality_score": 0.6,
  "generation_time_seconds": 151.28690266609192,
  "gigachat2_calls": 9,
  "gigachat3_calls": 36,
  "estimated_cost_usd": 0.036,
  "tools_used": [
    "web_search",
    "corrective_check",
    "adaptive_rag_search"
  ],
  "generation_id": "gen_37c7b21ddcdb",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Рекурсия и обход дерева  \n\n## Введение  \nДеревья — одна из важнейших структур данных в информатике, широко применяемая во многих областях программирования. Обход дерева — это процесс последовательного посещения всех его элементов. Существует несколько методов обхода, каждый из которых имеет свою специфику и область применения. Одним из наиболее эффективных подходов является использование рекурсии, позволяющей элегантно и эффективно решать задачи обработки древовидных структур.  \n\nРекурсия позволяет легко реализовать алгоритмы обхода дерева, такие как прямой, симметричный и обратный обходы. Эти методы позволяют последовательно обрабатывать узлы дерева, выполняя необходимые операции (например, вывод значений, вычисления и другие манипуляции).  \n\nКроме того, существуют специальные структуры, такие как декартовы деревья, позволяющие оптимизировать работу с деревьями поиска благодаря использованию дополнительного ключа сортировки. Это делает возможным эффективное выполнение операций поиска, вставки и удаления элементов.  \n\n## Основная теория  \n\n### Основные понятия  \n\n*Дерево* — это иерархическая структура данных, состоящая из узлов (*вершины*) и связей между ними (*ребра*). Каждый узел содержит данные и ссылки на дочерние узлы. У дерева есть один специальный узел — *корень*, который не имеет родителя. Остальные узлы называются листьями, если у них нет детей, либо внутренними вершинами, если имеют хотя бы одного ребёнка.  \n\nОбход дерева — это процедура, при которой каждая вершина посещается ровно один раз. Существуют три основные стратегии обхода:  \n\n- Прямой (preorder): обработка узла → левое поддерево → правое поддерево  \n- Симметричный (inorder): левое поддерево → обработка узла → правое поддерево  \n- Обратный (postorder): левое поддерево → правое поддерево → обработка узла  \n\nЭти способы отличаются порядком выполнения действий относительно текущего узла и его поддеревьев.  \n\n### Реализация через рекурсию  \n\nДля реализации обхода удобно использовать рекурсивную функцию, которая вызывает сама себя для обработки поддеревьев. Рассмотрим реализацию прямого обхода на примере бинарного дерева поиска:  \n\n```python\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef preorder_traversal(node):\n    if node is not None:\n        # Сначала обрабатываем текущий узел\n        print(node.value)\n        \n        # Затем переходим к левому поддереву\n        preorder_traversal(node.left)\n        \n        # И наконец к правому поддереву\n        preorder_traversal(node.right)\n```\n\nЭтот код демонстрирует принцип рекурсивного обхода: функция `preorder_traversal` вызывается сначала для корня, затем для его левого и правого поддеревьев.  \n\n### Время и пространство  \n\nВремя выполнения каждой из стратегий обхода составляет $O(n)$, где $n$ — количество узлов в дереве. Пространство также линейно зависит от глубины дерева ($O(h)$), поскольку рекурсивные вызовы занимают место в стеке.  \n\n## Практический пример: реализация обхода дерева  \n\nРассмотрим простую структуру бинарного дерева поиска и реализуем все три способа обхода:  \n\n```python\nclass BinaryTreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef insert(root, key):\n    \"\"\"Функция вставки элемента в бинарное дерево\"\"\"\n    if root is None:\n        return BinaryTreeNode(key)\n    \n    if key < root.key:\n        root.left = insert(root.left, key)\n    else:\n        root.right = insert(root.right, key)\n    \n    return root\n\n# Создаём дерево\nroot = None\nkeys = [10, 5, 15, 3, 7, 12, 18]\nfor k in keys:\n    root = insert(root, k)\n\n# Функция вывода результата обхода\ndef print_tree_traversal(traversal_type):\n    traversal_type(root)\n    print()\n\n# Реализуем три типа обхода\ndef preorder(node):\n    if node:\n        print(node.key, end=\" \")\n        preorder(node.left)\n        preorder(node.right)\n\ndef inorder(node):\n    if node:\n        inorder(node.left)\n        print(node.key, end=\" \")\n        inorder(node.right)\n\ndef postorder(node):\n    if node:\n        postorder(node.left)\n        postorder(node.right)\n        print(node.key, end=\" \")\n\nprint(\"Прямой обход:\")\nprint_tree_traversal(preorder)\n\nprint(\"Симметричный обход:\")\nprint_tree_traversal(inorder)\n\nprint(\"Обратный обход:\")\nprint_tree_traversal(postorder)\n```\n\nРезультатом выполнения программы будет следующее:  \n\n```\nПрямой обход:\n10 5 3 7 15 12 18 \nСимметричный обход:\n3 5 7 10 12 15 18 \nОбратный обход:\n3 7 5 12 18 15 10 \n```\n\nТаким образом, мы видим различия в порядке вывода ключей в зависимости от выбранного метода обхода.  \n\n## Специальные структуры: Декартово дерево  \n\nПомимо стандартных деревьев поиска, существуют специализированные структуры, такие как декартово дерево (`treap`), которое сочетает в себе свойства бинарного дерева поиска и бинарной кучи. Оно обладает двумя ключевыми особенностями:  \n\n- Элементы сортируются по первому ключу (как в BST), обеспечивая быстрый доступ и поиск.  \n- Второй ключ используется для поддержания свойств кучи, гарантирующих сбалансированность дерева.  \n\nЭто обеспечивает среднее время выполнения операций поиска, вставки и удаления порядка $O(\\log n)$.  \n\nПример реализации вставки в декартовом дереве выглядит следующим образом:  \n\n```python\nimport random\n\nclass TreapNode:\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()  # Случайный приоритет\n        self.left = None\n        self.right = None\n\ndef split(node, x):\n    \"\"\"Разделение дерева на два поддерева по значению x\"\"\"\n    if node is None:\n        return None, None\n    \n    if node.key <= x:\n        left, right = split(node.right, x)\n        node.right = left\n        return node, right\n    else:\n        left, right = split(node.left, x)\n        node.left = right\n        return left, node\n\ndef merge(left, right):\n    \"\"\"Объединение двух деревьев в одно\"\"\"\n    if left is None or right is None:\n        return left or right\n    \n    if left.priority > right.priority:\n        left.right = merge(left.right, right)\n        return left\n    else:\n        right.left = merge(left, right.left)\n        return right\n\ndef treap_insert(root, key):\n    new_node = TreapNode(key)\n    left, right = split(root, key)\n    return merge(merge(left, new_node), right)\n\n# Пример использования\nroot = None\nfor i in range(10):\n    root = treap_insert(root, i)\n```\n\nЗдесь мы используем две вспомогательные функции: `split`, разделяющую дерево на части, и `merge`, объединяющую эти части после вставки нового узла.  \n\n## Практические советы  \n\n1. **Избегать бесконечной рекурсии**: убедитесь, что условие выхода из рекурсии корректно задано.  \n   \n2. **Используйте стек вручную**, если глубина дерева велика, чтобы избежать переполнения стека.  \n   \n3. **Оптимизация памяти**: старайтесь минимизировать создание новых объектов при обработке больших деревьев.  \n   \n4. **Тестируйте разные случаи**: проверяйте поведение вашего решения на пустых деревьях, единичных узлах и несбалансированных структурах.  \n   \n5. **Анализ производительности**: оценивайте временную и пространственную сложность ваших решений перед внедрением в производственный код.  \n\n## Заключение  \n\nМы рассмотрели основы рекурсивного обхода деревьев, изучили различные подходы и реализовали их на практике. Мы также познакомились с продвинутым подходом — использованием декартовых деревьев, обеспечивающих высокую производительность операций поиска и модификации.  \n\nТеперь вы готовы применять полученные знания для эффективного решения задач, связанных с обработкой древовидных структур данных."
}