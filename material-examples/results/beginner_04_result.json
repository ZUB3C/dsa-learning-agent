{
  "topic_id": "beginner_04",
  "topic": "Связный список как структура данных",
  "user_level": "beginner",
  "success": true,
  "material_length": 5428,
  "word_count": 651,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.7,
  "documents_collected": 15,
  "completeness_score": 0.7,
  "relevance_score": 0.8,
  "quality_score": 0.8,
  "generation_time_seconds": 148.23655891418457,
  "gigachat2_calls": 9,
  "gigachat3_calls": 36,
  "estimated_cost_usd": 0.036,
  "tools_used": [
    "extract_concepts",
    "web_search",
    "adaptive_rag_search",
    "corrective_check"
  ],
  "generation_id": "gen_1f782ac4d964",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Связный список как структура данных  \n\n## Введение  \nСвязный список — одна из базовых структур данных, используемая для хранения последовательности элементов. Каждый элемент связанного списка содержит два компонента: данные и ссылку на следующий элемент. Это позволяет эффективно добавлять новые элементы в любое место списка без необходимости перемещать существующие элементы, как это происходит в массиве.  \n\nСвязные списки применяются там, где важна гибкость добавления и удаления элементов, особенно когда заранее неизвестно количество элементов или порядок их обработки. Например, такие структуры часто используются в операционных системах для управления памятью, в базах данных для организации индексов, а также в различных алгоритмах поиска и сортировки.  \n\n## Основная теория  \n\nСвязный список состоит из узлов (`node`), каждый узел хранит две части информации:  \n- `data` — сами данные узла (например, целое число, строка);  \n- `next` — ссылка на следующий узел в списке. Последний узел ссылается на специальный маркер конца списка (обычно обозначается как `null` или `None`).\n\nКлючевое преимущество связного списка заключается в возможности динамического изменения размера и порядка элементов без затрат памяти на перемещение существующих элементов. Однако доступ к элементу осуществляется последовательно, начиная с первого узла, что делает операцию случайного доступа менее эффективной по сравнению с массивом.  \n\nОсновные операции над связным списком включают:  \n- Добавление элемента в начало/конец/середину списка;  \n- Удаление элемента;  \n- Поиск элемента;  \n- Определение длины списка.  \n\nПространственная сложность связного списка составляет O(n), где n — количество элементов, поскольку каждому узлу соответствует отдельная область памяти. Время выполнения основных операций зависит от позиции элемента:  \n- Доступ к первому элементу — O(1);  \n- Обновление последнего элемента требует прохода по всему списку — O(n);  \n- Вставка/удаление элемента в середине списка — O(k), где k — позиция элемента.  \n\n## Пример реализации на Python  \nРассмотрим простую реализацию односвязного списка на Python:  \n```python\nclass Node:\n    def __init__(self, data=None):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    # Добавляем новый элемент в начало списка\n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    # Добавляем новый элемент в конец списка\n    def append(self, data):\n        if not self.head:\n            self.head = Node(data)\n            return\n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = Node(data)\n\n    # Печать содержимого списка\n    def display(self):\n        elements = []\n        current = self.head\n        while current:\n            elements.append(current.data)\n            current = current.next\n        print(elements)\n```\n\nПример использования:  \n```python\nllist = LinkedList()\nllist.prepend(\"Москва\")\nllist.append(\"Санкт-Петербург\")\nllist.display()  # ['Москва', 'Санкт-Петербург']\n```\n\n## Практический пример: реализация очереди FIFO  \nОчереди (First-In-First-Out) удобно реализовывать с использованием связных списков. Рассмотрим классическую реализацию очереди на основе связного списка:  \n```python\nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n\n    def is_empty(self):\n        return self.front is None\n\n    def enqueue(self, item):  # Добавляем элемент в конец очереди\n        temp = Node(item)\n        if self.rear is None:\n            self.front = self.rear = temp\n            return\n        self.rear.next = temp\n        self.rear = temp\n\n    def dequeue(self):  # Убираем первый элемент из очереди\n        if self.is_empty():\n            return None\n        temp = self.front\n        self.front = temp.next\n        if self.front is None:\n            self.rear = None\n        return temp.data\n```\n\n## Сравнение с аналогами  \n\n| Характеристика | Массивы | Связные списки |\n|----------------|---------|-----------------|\n| Случайный доступ | Быстрый (O(1)) | Медленный (O(n)) |\n| Вставка/Удаление | Медленная (O(n)) | Быстрая (O(1)/O(k)) |\n| Размерность | Фиксированная | Динамическая |\n| Использование памяти | Эффективнее | Менее эффективно (из-за ссылок) |\n\nСвязные списки лучше подходят для ситуаций, когда важны частые вставки и удаления элементов, тогда как массивы предпочтительнее, если нужен быстрый доступ к конкретному индексу.  \n\n## Практические советы  \n\n- Всегда проверяйте, является ли список пустым, чтобы избежать ошибок обращения к несуществующим элементам.  \n- Используйте вспомогательные функции для упрощения операций (например, метод `display()` для вывода всех элементов).  \n- Не забывайте освобождать память, если используете языки программирования с ручным управлением памятью (C/C++).  \n- Старайтесь избегать циклических ссылок, иначе вы можете столкнуться с проблемами бесконечного цикла.  \n\n## Дополнительные ресурсы  \n- [Лекция 4](./лекция_4.pdf) — подробное описание принципов работы связных списков.  \n- [Алгоритмы и структуры данных](./алгоритмы_и_структуры_данных.pdf) — книга с глубокими теоретическими основами.  \n\nТаким образом, связный список — простая, но мощная структура данных, позволяющая эффективно решать широкий спектр задач, связанных с обработкой последовательностей элементов."
}