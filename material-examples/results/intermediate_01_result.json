{
  "topic_id": "intermediate_01",
  "topic": "Бинарный поиск",
  "user_level": "intermediate",
  "success": true,
  "material_length": 4932,
  "word_count": 651,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.7,
  "documents_collected": 9,
  "completeness_score": 0.7,
  "relevance_score": 0.8,
  "quality_score": 0.7,
  "generation_time_seconds": 139.63900566101074,
  "gigachat2_calls": 8,
  "gigachat3_calls": 32,
  "estimated_cost_usd": 0.032,
  "tools_used": [
    "extract_concepts",
    "web_search",
    "adaptive_rag_search",
    "corrective_check"
  ],
  "generation_id": "gen_82c2b3714a14",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Учебный материал по теме «Бинарный поиск»\n\n## Уровень подготовки: Intermediate\n\n### 1. Введение\n\nПоиск данных является одной из важнейших операций в программировании. Часто возникает необходимость быстрого поиска элемента среди большого количества данных. Один из наиболее эффективных методов поиска — **бинарный поиск**. Этот алгоритм позволяет находить нужный элемент в отсортированном массиве значительно быстрее, чем обычный перебор.\n\nПочему важен бинарный поиск? Представьте себе ситуацию, когда вам нужно найти конкретный номер телефона в телефонной книге объемом в миллионы записей. Если искать простым перебором, это займет огромное количество времени. Но если применить бинарный поиск, результат можно получить почти мгновенно!\n\n### 2. Основная теория\n\n#### 2.1 Определение и принцип работы\n\n**Бинарный поиск** (binary search) — это эффективный алгоритм поиска элемента в отсортированной последовательности. Его основная идея заключается в следующем:\n\n- Сначала выбирается центральный элемент массива.\n- Затем сравнивается значение центрального элемента с искомым элементом.\n- Если центральное значение совпадает с искомым, поиск завершен.\n- Если искомое значение меньше центрального, дальнейший поиск продолжается в левой половине массива.\n- Если искомое значение больше центрального, поиск продолжается в правой половине массива.\n- Процесс повторяется, пока не найдется нужный элемент или пока область поиска не станет пустой.\n\nТаким образом, каждый шаг уменьшает размер области поиска вдвое, что делает алгоритм чрезвычайно эффективным.\n\n#### 2.2 Временная и пространственная сложность\n\n- **Временная сложность**: $O(\\log n)$, где $n$ — длина массива. Благодаря делению пополам на каждом шаге, количество шагов растет логарифмически относительно размера массива.\n  \n- **Пространственная сложность**: $O(1)$ (константная), поскольку используется лишь фиксированное количество переменных вне зависимости от размера массива.\n\n#### 2.3 Условия применения\n\nБинарный поиск возможен только в тех случаях, когда исходные данные отсортированы. Если массив не отсортирован, сначала потребуется провести сортировку, что увеличит общую временную сложность операции.\n\n### 3. Примеры\n\n#### 3.1 Поиск числа в отсортированном массиве\n\nДопустим, у нас есть отсортированный массив чисел:\n\n```python\narr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\ntarget = 11\n```\n\nРеализуем бинарный поиск на Python:\n\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid  # Возвращаем индекс найденного элемента\n        elif arr[mid] < target:\n            left = mid + 1  # Продолжаем поиск справа\n        else:\n            right = mid - 1  # Продолжаем поиск слева\n            \n    return None  # Элемента нет в массиве\n\nresult = binary_search(arr, target)\nprint(f'Элемент {target} находится на индексе {result}')\n```\n\nРезультатом выполнения будет:\n\n```\nЭлемент 11 находится на индексе 5\n```\n\n#### 3.2 Поиск минимального элемента в отсортированном повернутом массиве\n\nИногда массив изначально отсортирован, но был повёрнут (циклически сдвинут). Например:\n\n```python\narr = [15, 17, 19, 1, 3, 5, 7, 9, 11, 13]\n```\n\nЗдесь минимальный элемент — `1`. Реализация бинарного поиска для нахождения минимума:\n\n```python\ndef find_min_in_rotated_array(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if arr[mid] > arr[right]:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return arr[left]\n\nmin_value = find_min_in_rotated_array(arr)\nprint(f'Минимальный элемент: {min_value}')\n```\n\nРезультат:\n\n```\nМинимальный элемент: 1\n```\n\n### 4. Сравнение с аналогами\n\n| Метод поиска | Средняя сложность |\n|--------------|------------------|\n| Последовательный поиск | $O(n)$           |\n| Бинарный поиск         | $O(\\log n)$      |\n\nПреимущества бинарного поиска перед обычным перебором:\n- Значительно меньшая временная сложность ($O(\\log n)$ против $O(n)$).\n- Эффективность даже на огромных объемах данных.\n\nНедостатки:\n- Требует предварительно отсортированного массива.\n- Не подходит для динамических наборов данных, которые часто обновляются.\n\n### 5. Практические советы\n\n- Всегда убедитесь, что ваш массив отсортирован перед началом поиска.\n- Используйте встроенные функции библиотек (например, bisect в Python), если возможно.\n- Будьте осторожны с граничными условиями (массивы длиной 0 или 1).\n- Помните, что бинарный поиск неэффективен для небольших объемов данных (<10–20 элементов).\n\n### 6. Дополнительные ресурсы\n\nРекомендуемые материалы для углубленного изучения темы:\n- Лекции по алгоритмам и структурам данных (см. раздел \"Алгоритмы и структуры данных\").\n- Задачи на платформе LeetCode и Codeforces.\n\n---\n\nЭтот материал поможет разобраться в особенностях бинарного поиска и эффективно применять его на практике."
}