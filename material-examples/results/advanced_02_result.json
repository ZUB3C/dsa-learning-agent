{
  "topic_id": "advanced_02",
  "topic": "Алгоритм Дейкстры",
  "user_level": "advanced",
  "success": true,
  "material_length": 5011,
  "word_count": 584,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.4,
  "documents_collected": 3,
  "completeness_score": 0.4,
  "relevance_score": 0.7,
  "quality_score": 0.7,
  "generation_time_seconds": 133.84849977493286,
  "gigachat2_calls": 8,
  "gigachat3_calls": 32,
  "estimated_cost_usd": 0.032,
  "tools_used": [
    "extract_concepts",
    "adaptive_rag_search",
    "web_search",
    "corrective_check"
  ],
  "generation_id": "gen_d84149322bd7",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Алгоритм Дейкстры — продвинутый уровень\n\n## Введение\n\nАлгоритм Дейкстры — один из наиболее известных методов поиска кратчайшего пути в графах с неотрицательными весами рёбер. Разработан нидерландским учёным Эдсгером Дейкстрой в 1959 году. Этот алгоритм широко используется в различных областях информатики и компьютерных технологий, включая маршрутизацию сетей, навигационные системы, планирование ресурсов и многие другие задачи оптимизации.\n\nЭффективность и универсальность делают алгоритм Дейкстры незаменимым инструментом для специалистов, работающих над проектами, связанными с обработкой графовых моделей и поиском эффективных путей.\n\n## Основная теория\n\n### Концепция и принцип работы\n\nАлгоритм Дейкстры решает задачу поиска кратчайшего пути от одной вершины графа до остальных. Его основная идея основана на постепенном расширении множества посещённых вершин, начиная с начальной вершины, и поддержании расстояния до каждой вершины в виде минимальной стоимости достижения этой вершины.\n\nКлючевая особенность алгоритма — использование приоритетной очереди (обычно реализованной через кучу), где вершинам присваиваются приоритеты, соответствующие текущим оценкам расстояний.\n\n#### Основные шаги алгоритма:\n\n1. Инициализация:\n   - Все вершины помечаются как непосещённые.\n   - Расстояние до стартовой вершины устанавливается равным нулю, остальные — бесконечности.\n   \n2. Основной цикл:\n   - Выбирается ближайшая непосещённая вершина.\n   - Для выбранной вершины пересчитываются расстояния до соседних вершин.\n   - Вершина отмечается как посещённая.\n   \n3. Повторение цикла до посещения всех вершин или достижения целевой вершины.\n\n### Формальное описание\n\nПусть дан ориентированный взвешенный граф $G=(V,E)$, где $V$ — множество вершин, $E$ — множество рёбер, каждое ребро $(u,v)$ имеет вес $w(u,v)$. Необходимо найти кратчайшие пути от исходной вершины $s$ ко всем остальным вершинам.\n\nАлгоритм работает следующим образом:\n\n```python\ndef dijkstra(graph, start):\n    # Инициализация расстояний и предыдущих вершин\n    distances = {vertex: float('inf') for vertex in graph}\n    previous_vertices = {vertex: None for vertex in graph}\n    \n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_vertex = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_vertex]:\n            continue\n            \n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous_vertices[neighbor] = current_vertex\n                heapq.heappush(priority_queue, (distance, neighbor))\n                \n    return distances, previous_vertices\n```\n\n### Временная и пространственная сложность\n\n- **Время работы**: $O((|V|+|E|)\\log|V|)$ при использовании бинарной кучи.\n- **Память**: $O(|V|)$.\n\n## Примеры\n\nРассмотрим пример простого графа с пятью вершинами и положительными весами рёбер:\n\n```python\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\nstart_vertex = 'A'\ndistances, path = dijkstra(graph, start_vertex)\nprint(\"Кратчайшие расстояния:\", distances)\nprint(\"Предыдущие вершины:\", path)\n```\n\nРезультатом будет словарь кратчайших расстояний и путь восстановления маршрута.\n\n## Сравнение с аналогами\n\n### Bellman-Ford vs Dijkstra\n\n- **Bellman-Ford** позволяет находить кратчайшие пути даже в графах с отрицательными весами рёбер, однако его временная сложность значительно хуже ($O(|V|\\cdot |E|)$).\n  \n- **Dijkstra** быстрее, но требует неотрицательных весов рёбер.\n\n### A* vs Dijkstra\n\n- **A*** добавляет эвристику, ускоряя процесс поиска путём оценки перспективности направлений движения. Однако корректность результата зависит от качества эвристики.\n\n- **Dijkstra** гарантированно находит оптимальный путь, но не учитывает дополнительную информацию о структуре графа.\n\n## Практические советы\n\n1. Всегда проверяйте наличие циклов с отрицательным весом перед применением алгоритма.\n2. Используйте эффективные структуры данных (например, очередь с приоритетом) для ускорения вычислений.\n3. Обновляйте расстояние до вершины только тогда, когда оно действительно уменьшается.\n4. Не забывайте учитывать граничные случаи (графы с одной вершиной, пустые графы).\n5. Реализация алгоритма на практике часто включает дополнительные проверки и обработки ошибок.\n\n## Дополнительные ресурсы\n\n- [Специализация \"Алгоритмы и структуры данных\"](https://example.com/algorithms-specialization)\n- [Курс Алексея Панфилова](https://stepik.org/course/algorithm-course)\n- Книга \"Introduction to Algorithms\" by Thomas H. Cormen et al.\n\nТаким образом, понимание и применение алгоритма Дейкстры открывает широкие возможности для эффективного решения задач поиска кратчайших путей в графах, делая его важным элементом арсенала любого специалиста по алгоритмам и структурам данных."
}