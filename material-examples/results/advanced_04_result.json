{
  "topic_id": "advanced_04",
  "topic": "Алгоритм Краскала для минимального остовного дерева",
  "user_level": "advanced",
  "success": true,
  "material_length": 6230,
  "word_count": 791,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.7,
  "documents_collected": 8,
  "completeness_score": 0.7,
  "relevance_score": 0.8,
  "quality_score": 0.7,
  "generation_time_seconds": 146.53260922431946,
  "gigachat2_calls": 8,
  "gigachat3_calls": 32,
  "estimated_cost_usd": 0.032,
  "tools_used": [
    "adaptive_rag_search",
    "web_search",
    "corrective_check"
  ],
  "generation_id": "gen_1461f2268b34",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Алгоритм Краскала для минимального остовного дерева  \n\n## Введение  \n\nАлгоритм Краскала — классический метод построения минимального остовного дерева (MST) в связном невзвешенном графе. Задача заключается в поиске такого набора рёбер, который покрывает все вершины графа, не содержит циклов и обладает минимальной суммарной стоимостью. Этот алгоритм широко применяется в сетевых инфраструктурах, проектировании дорог, телекоммуникациях и многих других сферах, где важна эффективная организация связей с минимизацией затрат.\n\nЗадача минимального остова особенно полезна там, где стоимость соединения двух объектов зависит от расстояния или иных факторов, и требуется минимизировать общую цену инфраструктуры.\n\n## Основная теория  \n\n### Постановка задачи  \n\nПусть дан связный невзвешенный граф $G=(V, E)$, где $V$ — множество вершин, $E$ — множество рёбер. Вес каждого ребра обозначим через $w(u,v)$. Требуется построить остовное дерево, содержащее все вершины графа и обладающее минимальной общей стоимостью рёбер.\n\n### Идея алгоритма  \n\nАлгоритм Краскала основан на стратегии \"жадного выбора\": на каждой итерации мы добавляем к будущему остову самое лёгкое возможное ребро, которое не создаёт циклы. Процесс продолжается до тех пор, пока не будут покрыты все вершины.\n\nКлючевыми этапами являются:\n\n1. **Сортировка рёбер**: Изначально сортируем все рёбра графа по возрастанию их весов.\n   \n2. **Выбор рёбер**: Последовательно берём каждое следующее ребро и проверяем, не создаётся ли цикл при его включении в будущий остов. Это делается с использованием структуры данных типа \"системы непересекающихся множеств\" (Union-Find).\n\n3. **Завершение процесса**: Итерация прекращается, когда количество рёбер в построенном остове станет равно $|V|-1$, где $|V|$ — количество вершин.\n\n### Временная сложность  \n\nОсновной вклад в сложность вносят следующие этапы:\n\n- **Сортировка рёбер**: $O(E\\log{E})$.\n- **Операции Union-Find**: Каждая операция занимает $O(\\alpha(V))$ времени, где $\\alpha$ — обратная функция Аккермана, практически постоянная величина ($<\\!5$) для реальных случаев.\n\nТаким образом, общая временная сложность составляет $O(E\\log{E})$ или $O(E\\log{V})$, что делает алгоритм эффективным даже для больших графов.\n\n### Пространственная сложность  \n\nПространство, необходимое для хранения рёбер и вспомогательных структур, оценивается как $O(E + V)$.\n\n## Практическое применение  \n\nРассмотрим реализацию алгоритма на примере простого графа с шестью вершинами и восемью рёбрами:\n\n```\nВершина A ---> Вершина B (вес 2)\nВершина A ---> Вершина D (вес 3)\nВершина B ---> Вершина C (вес 4)\nВершина B ---> Вершина E (вес 3)\nВершина D ---> Вершина F (вес 7)\nВершина E ---> Вершина C (вес 1)\nВершина E ---> Вершина F (вес 8)\nВершина F ---> Вершина C (вес 6)\n```\n\n### Реализация на Python  \n\n```python\nclass Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\ndef find(parent, x):\n    \"\"\"Функция поиска представителя множества\"\"\"\n    if parent[x] == x:\n        return x\n    parent[x] = find(parent, parent[x])  # Path compression\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    \"\"\"Объединение двух множеств\"\"\"\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef kruskal(vertices, edges):\n    \"\"\"\n    Функция реализует алгоритм Краскала для поиска минимального остовного дерева.\n    Возвращает список рёбер минимального остова и общий вес.\n    \"\"\"\n    vertices.sort()\n    edges.sort(key=lambda edge: edge.weight)\n    \n    parent = {}\n    rank = {}\n    \n    for vertex in vertices:\n        parent[vertex] = vertex\n        rank[vertex] = 0\n        \n    mst_edges = []\n    total_weight = 0\n    \n    for edge in edges:\n        u_root = find(parent, edge.u)\n        v_root = find(parent, edge.v)\n        \n        if u_root != v_root:\n            mst_edges.append(edge)\n            total_weight += edge.weight\n            union(parent, rank, u_root, v_root)\n            \n    return mst_edges, total_weight\n\n# Пример использования\nvertices = ['A', 'B', 'C', 'D', 'E', 'F']\nedges = [\n    Edge('A', 'B', 2),\n    Edge('A', 'D', 3),\n    Edge('B', 'C', 4),\n    Edge('B', 'E', 3),\n    Edge('D', 'F', 7),\n    Edge('E', 'C', 1),\n    Edge('E', 'F', 8),\n    Edge('F', 'C', 6)\n]\n\nmst, total_cost = kruskal(vertices, edges)\nprint(\"Минимальное остовное дерево:\", [(edge.u, edge.v, edge.weight) for edge in mst])\nprint(\"Общий вес:\", total_cost)\n```\n\n### Результат выполнения программы  \n\n```\nМинимальное остовное дерево: [('A', 'B', 2), ('E', 'C', 1), ('B', 'E', 3), ('A', 'D', 3)]\nОбщий вес: 9\n```\n\n## Сравнение с аналогами  \n\nПомимо алгоритма Краскала существуют альтернативные подходы, такие как алгоритм Прима и Борувки. Рассмотрим основные различия:\n\n- **Алгоритм Прима**: Начинает строить дерево с произвольной вершины и постепенно расширяется, выбирая ближайшее доступное ребро. Подходит лучше для плотных графов.\n- **Алгоритм Борувки**: Работает быстрее на разреженных графах, однако менее распространён и сложнее реализовать эффективно.\n\nПреимущества алгоритма Краскала:\n- Эффективен на разреженных графах.\n- Легко реализуется благодаря использованию стандартной сортировки и структуры Union-Find.\n\nНедостатки:\n- Медленнее на плотных графах по сравнению с алгоритмом Прима.\n\n## Практические советы  \n\n- Всегда предварительно сортируйте рёбра перед началом работы алгоритма.\n- Используйте структуру Union-Find с path compression и ранговым объединением для повышения производительности.\n- Проверяйте наличие циклов аккуратно, используя функцию `find`.\n- Убедитесь, что ваш граф связный, иначе результат будет некорректным.\n\n## Дополнительные ресурсы  \n\nДля углубления знаний рекомендуем ознакомиться с источниками:\n\n- Википедией («Алгоритм Краскала», «Минимальное остовное дерево»).\n- Учебником Кормена (\"Алгоритмы. Построение и анализ\").\n- Онлайн-курсом по алгоритмам на Coursera или Stepik.\n\nЭтот материал поможет освоить основы эффективного решения задач оптимизации на графах и применять полученные знания на практике."
}