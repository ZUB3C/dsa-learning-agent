{
  "topic_id": "intermediate_03",
  "topic": "Хеш-таблицы как структура данных",
  "user_level": "intermediate",
  "success": true,
  "material_length": 6564,
  "word_count": 783,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.65,
  "documents_collected": 5,
  "completeness_score": 0.65,
  "relevance_score": 0.9,
  "quality_score": 0.7,
  "generation_time_seconds": 154.7112638950348,
  "gigachat2_calls": 9,
  "gigachat3_calls": 36,
  "estimated_cost_usd": 0.036,
  "tools_used": [
    "web_search",
    "adaptive_rag_search"
  ],
  "generation_id": "gen_f801b2bfd171",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Учебный материал  \n## Хеш-таблицы как структура данных  \n\n### Уровень подготовки: Intermediate  \n\n#### Автор: GigaChat  \n\n---\n\n## Введение  \n\nХеш-таблица — это структура данных, позволяющая эффективно хранить и быстро извлекать данные по уникальному идентификатору, называемому ключом. Она широко используется там, где важна высокая скорость операций поиска, добавления и удаления элементов. Например, базы данных, кэш-память, компиляторы и интерпретаторы используют хеш-таблицы для быстрого доступа к данным. \n\nЭффективность хеш-таблиц обусловлена использованием специальной функции — хеш-функции, которая преобразует ключи в индексы массива. Однако, поскольку разные ключи могут давать одинаковые значения индекса (коллизии), существуют различные способы обработки таких ситуаций.  \n\n---\n\n## Основная теория  \n\n### Концепция хеш-таблиц  \n\nХеш-таблица представляет собой массив фиксированного размера (`HASHSIZE`), каждый элемент которого содержит либо сам объект (ключ-значение), либо ссылку на структуру данных, хранящую такие объекты. Для преобразования ключей в индексы массива используется специальная функция — хеш-функция.  \n\nНапример, пусть размер нашей хеш-таблицы равен `10`, а хеш-функция возвращает остаток от деления ключа на этот размер (`key % HASHSIZE`):  \n\n```python\ndef hash_function(key):\n    return key % 10\n```\n\nТогда ключ `\"Москва\"` (числовое представление строки) будет размещён в ячейке с номером `hash_function(\"Москва\")`.  \n\n### Обработка коллизий  \n\nКоллизией называется ситуация, когда два разных ключа отображаются одной и той же хеш-функцией в один и тот же индекс массива. Существует два основных подхода к обработке коллизий:  \n\n1. **Открытая адресация**: элементы хранятся непосредственно в самом массиве, а при возникновении коллизии используются специальные техники размещения новых элементов (например, линейное зондирование, квадратичное зондирование, двойное хеширование).  \n   \n2. **Закрытая адресация (метод цепочек)**: каждая ячейка массива содержит указатель на связанный список (или другое дерево поиска), куда добавляются конфликтующие элементы. Этот метод позволяет легко добавлять новые элементы, однако увеличивает накладные расходы памяти.  \n\n### Пример закрытой адресации  \n\nРассмотрим пример хеш-таблицы размером `5`, используя закрытую адресацию методом цепочек:  \n\n| Индекс | Элемент |\n|--------|---------|\n| 0      | NULL    |\n| 1      | [\"Ключ1\"] -> [\"Ключ2\"] |\n| 2      | NULL    |\n| 3      | [\"Ключ3\"] |\n| 4      | NULL    |\n\nЗдесь при попытке добавить новый элемент с ключом, дающим тот же индекс, происходит создание нового узла в связанном списке.  \n\n### Временная и пространственная сложность  \n\nИдеальная хеш-таблица имеет временную сложность операций поиска, вставки и удаления равную O(1) в среднем случае. Однако в худшем сценарии (при большом количестве коллизий) эти операции могут деградировать до O(n).  \n\nПространственная сложность зависит от выбранного метода разрешения коллизий:  \n\n- Открытая адресация требует меньше дополнительной памяти, но сложнее обрабатывается при высокой плотности заполнения.  \n- Закрытая адресация потребляет больше памяти за счёт связанных списков, но проще реализуется и масштабируется лучше.  \n\n---\n\n## Практика  \n\n### Пример №1: Реализация хеш-таблицы с закрытым адресованием  \n\nРеализуем простую хеш-таблицу с разрешением коллизий методом цепочек на Python:  \n\n```python\nclass HashTable:\n    def __init__(self, size=10):\n        self.size = size\n        # Массив ссылок на связанные списки\n        self.table = [None for _ in range(size)]\n    \n    def hash_function(self, key):\n        return sum(bytearray(key.encode())) % self.size\n    \n    def insert(self, key, value):\n        index = self.hash_function(key)\n        \n        if not self.table[index]:\n            # Создаём новую цепь\n            self.table[index] = [(key, value)]\n        else:\n            # Добавляем в существующую цепь\n            self.table[index].append((key, value))\n    \n    def search(self, key):\n        index = self.hash_function(key)\n        chain = self.table[index]\n        \n        if chain is None:\n            return None\n        \n        for k, v in chain:\n            if k == key:\n                return v\n        return None\n    \n    def delete(self, key):\n        index = self.hash_function(key)\n        chain = self.table[index]\n        \n        if chain is None:\n            return False\n        \n        for i, pair in enumerate(chain):\n            if pair[0] == key:\n                del chain[i]\n                return True\n        return False\n```\n\n### Объяснение  \n\n1. Мы инициализировали таблицу заданного размера, заполнив её значениями `None`.\n2. Функция `insert()` добавляет парные записи `{ключ, значение}` в соответствующую позицию массива.\n3. Метод `search()` ищет значение по указанному ключу, проходя по связанной цепи.\n4. Операция `delete()` удаляет запись, находя её в соответствующей цепи.  \n\n---\n\n## Сравнение с аналогами  \n\n### Другие структуры данных  \n\n- **Массивы**: обеспечивают быстрый доступ по индексу, но требуют заранее известного количества элементов и неэффективны при частых операциях вставки и удаления.  \n- **Связанные списки**: поддерживают произвольные вставки и удаление, но имеют медленный доступ к элементам (O(n)).  \n- **Деревья поиска**: предоставляют эффективный баланс скорости поиска и модификации, но занимают больше памяти и сложны в реализации.  \n\nПреимущества хеш-таблиц заключаются в быстрой работе большинства операций (O(1)) и относительной простоте реализации. Основные недостатки — необходимость хорошей хеш-функции и проблемы с обработкой коллизий.  \n\n---\n\n## Практические советы  \n\n1. **Выбирайте хорошую хеш-функцию**. Чем равномернее распределение значений, тем ниже вероятность коллизий.  \n2. **Используйте подходящий коэффициент загрузки**. Поддерживайте нагрузку на уровне ~0.7–0.8, чтобы минимизировать риск замедления операций.  \n3. **Избегайте чрезмерного увеличения размеров таблиц**, иначе вы потеряете преимущества эффективности.  \n4. **Рассмотрите использование готовых библиотек**. Многие языки программирования уже содержат эффективные реализации хеш-таблиц (например, словарь `dict` в Python).  \n\n---\n\n## Дополнительные ресурсы  \n\n- Книга: Thomas H. Cormen et al., \"Introduction to Algorithms\".  \n- Курс: \"Algorithms, Part I\" by Robert Sedgewick on Coursera.  \n- Документация: Официальная документация Python по встроенным типам данных.  \n\n---\n\nЭтот материал подготовлен для уровня intermediate и охватывает основные аспекты хеш-таблиц, позволяя глубже разобраться в этой важной структуре данных."
}