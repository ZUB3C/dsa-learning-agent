{
  "topic_id": "advanced_03",
  "topic": "AVL-деревья",
  "user_level": "advanced",
  "success": true,
  "material_length": 6945,
  "word_count": 854,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.6,
  "documents_collected": 9,
  "completeness_score": 0.6,
  "relevance_score": 0.7,
  "quality_score": 0.7,
  "generation_time_seconds": 189.26531195640564,
  "gigachat2_calls": 9,
  "gigachat3_calls": 36,
  "estimated_cost_usd": 0.036,
  "tools_used": [
    "web_search",
    "adaptive_rag_search",
    "corrective_check"
  ],
  "generation_id": "gen_0c2b1b60dfc0",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Учебный материал по AVL-деревьям  \n\n## Введение  \n\nAVL-дерево — это разновидность бинарного дерева поиска, названная в честь советских ученых Г. М. Адельсона-Вельского и Е. М. Ланди́са, предложивших эту структуру в 1962 году. Основная цель AVL-дерева — обеспечить высокую эффективность операций поиска, добавления и удаления элементов путем поддержания баланса дерева.  \n\nПочему это важно?  \n\n- Высокая скорость доступа к данным ($O(\\log n)$) даже в худшем случае.  \n- Устойчивая производительность независимо от последовательности вставляемых элементов.  \n- Широкая область применения: базы данных, файловые системы, компиляторы, поисковые движки и другие приложения, где важна высокая скорость обработки запросов.  \n\nГде применяется?  \n\n- Хранение больших объемов упорядоченных данных.  \n- Реализация эффективных алгоритмов поиска и сортировки.  \n- Поддержание индексации в системах управления базами данных.  \n- Использование в качестве основы для более сложных структур данных.  \n\n## Основная теория  \n\n### Определение и принцип работы  \n\nAVL-дерево — это самоорганизующаяся структура данных, представляющая собой бинарное дерево поиска, которое поддерживает балансировку своей структуры. Основное свойство AVL-дерева заключается в том, что абсолютная разница высот левого и правого поддеревьев любого узла не превышает единицы.  \n\nФормальное определение:  \n\n> Высота AVL-дерева определяется как максимальная длина пути от корня до листа. Условие балансировки гласит, что для каждого узла $|h_{левое}-h_{правое}| \\leq 1$, где $h$ — высота соответствующего поддерева.  \n\n### Операции над AVL-деревом  \n\n#### 1. Поиск элемента  \nПоиск выполняется стандартным способом, как в обычном бинарном дереве поиска. Время поиска — $O(\\log n)$.  \n\n#### 2. Вставка нового элемента  \nПосле стандартной вставки проверяется условие балансировки. Если нарушается баланс, выполняются специальные вращения для восстановления равновесия. Возможны четыре типа вращений:  \n\n- Малое левое вращение (LL)  \n- Большое левое вращение (LR)  \n- Малое правое вращение (RR)  \n- Большое правое вращение (RL)  \n\n#### 3. Удаление элемента  \nУдаление происходит аналогично обычному бинарному дереву поиска, однако после удаления снова проверяется балансировка и при необходимости восстанавливается с помощью вращений.  \n\n### Пример работы механизма балансировки  \n\nРассмотрим пример вставки числа `1` в следующее дерево:  \n```\n      5\n     / \\\n    3   7\n       /\n      6\n```  \n\nПосле вставки число `1`:  \n```\n      5\n     / \\\n    1   7\n   /   \n  3     \n     \\\n      6\n```  \n\nТеперь дерево несбалансированно, поскольку высота левого поддерева стала больше правой на два. Выполняем малое правое вращение вокруг узла `5`, получая сбалансированную структуру:  \n```\n      3\n     / \\\n    1   5\n         \\\n          7\n         /\n        6\n```  \n\n### Временная и пространственная сложность  \n\n| Операция | Средняя сложность | Худшая сложность |\n|----------|------------------|-----------------|\n| Поиск    | $O(\\log n)$      | $O(\\log n)$     |\n| Вставка  | $O(\\log n)$      | $O(\\log n)$     |\n| Удаление | $O(\\log n)$      | $O(\\log n)$     |\n\nПространственная сложность: $O(n)$, где $n$ — количество элементов в дереве.  \n\n## Практический пример  \n\nДавайте реализуем простую реализацию AVL-дерева на Python:  \n\n```python\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\ndef height(node):\n    if node is None:\n        return 0\n    return node.height\n\ndef update_height(node):\n    node.height = max(height(node.left), height(node.right)) + 1\n\ndef get_balance_factor(node):\n    if node is None:\n        return 0\n    return height(node.left) - height(node.right)\n\ndef rotate_left(z):\n    y = z.right\n    T2 = y.left\n    \n    # Perform rotation\n    y.left = z\n    z.right = T2\n    \n    # Update heights\n    update_height(z)\n    update_height(y)\n    \n    return y\n\ndef rotate_right(x):\n    y = x.left\n    T2 = y.right\n    \n    # Perform rotation\n    y.right = x\n    x.left = T2\n    \n    # Update heights\n    update_height(x)\n    update_height(y)\n    \n    return y\n\ndef insert(root, key):\n    if root is None:\n        return Node(key)\n    \n    if key < root.key:\n        root.left = insert(root.left, key)\n    else:\n        root.right = insert(root.right, key)\n        \n    update_height(root)\n    \n    balance = get_balance_factor(root)\n    \n    # Left Left Case\n    if balance > 1 and key < root.left.key:\n        return rotate_right(root)\n    \n    # Right Right Case\n    if balance < -1 and key > root.right.key:\n        return rotate_left(root)\n    \n    # Left Right Case\n    if balance > 1 and key > root.left.key:\n        root.left = rotate_left(root.left)\n        return rotate_right(root)\n    \n    # Right Left Case\n    if balance < -1 and key < root.right.key:\n        root.right = rotate_right(root.right)\n        return rotate_left(root)\n    \n    return root\n\ndef inorder_traversal(root):\n    if root:\n        inorder_traversal(root.left)\n        print(root.key, end=\" \")\n        inorder_traversal(root.root)\n\n# Тестируем нашу функцию\nroot = None\nkeys = [9, 5, 10, 0, 6, 11, -1, 1, 2]\nfor key in keys:\n    root = insert(root, key)\ninorder_traversal(root)\n```\n\nРезультатом будет вывод элементов в порядке возрастания:  \n```\n-1 0 1 2 5 6 9 10 11 \n```\n\n## Сравнение с аналогами  \n\n### Бинарные деревья поиска (BST)  \n\n- **Преимущества**: проще реализация, меньше накладных расходов.  \n- **Недостатки**: возможны случаи деградации до списка, приводящие к ухудшению производительности до $O(n)$.  \n\n### Красно-чёрные деревья  \n\n- **Преимущества**: менее строгие условия балансировки позволяют снизить частоту перестроений.  \n- **Недостатки**: немного медленнее в среднем случае, сложнее логика балансировки.  \n\n### B-деревья  \n\n- **Преимущества**: хорошо подходят для внешних хранилищ, поддерживают массовую обработку данных.  \n- **Недостатки**: сложная реализация, большие затраты памяти на хранение метаданных.  \n\n## Практические советы  \n\n1. Всегда проверяйте балансировку после любых изменений структуры дерева.  \n2. Используйте рекурсивную реализацию для простоты понимания и поддержки.  \n3. Не забывайте обновлять высоту узлов после каждого изменения.  \n4. Регулярно тестируйте вашу реализацию на разных наборах данных.  \n5. Помните, что AVL-дерево обеспечивает стабильную производительность, но требует дополнительной вычислительной нагрузки на поддержание баланса.  \n\n## Дополнительные ресурсы  \n\n- Книга: Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Ривест, Клифорд Штайн. Алгоритмы: построение и анализ.  \n- Онлайн-курс: Coursera — Algorithms Specialization by Stanford University.  \n- Документация: Официальная документация Python по работе с деревьями и структурами данных.  \n\nТаким образом, AVL-дерево — мощная структура данных, обеспечивающая эффективную работу с большими объемами данных и поддерживающая высокий уровень производительности даже в неблагоприятных сценариях."
}