{
  "topic_id": "advanced_05",
  "topic": "Алгоритм Кнута-Морриса-Пратта KMP",
  "user_level": "advanced",
  "success": true,
  "material_length": 5618,
  "word_count": 708,
  "tot_iterations": 18,
  "explored_nodes": 18,
  "final_completeness": 0.6,
  "documents_collected": 6,
  "completeness_score": 0.6,
  "relevance_score": 0.8,
  "quality_score": 0.7,
  "generation_time_seconds": 138.0051257610321,
  "gigachat2_calls": 8,
  "gigachat3_calls": 32,
  "estimated_cost_usd": 0.032,
  "tools_used": [
    "web_search",
    "corrective_check",
    "adaptive_rag_search"
  ],
  "generation_id": "gen_3b3f2f9bac43",
  "warnings": [],
  "fallbacks_used": [],
  "error": null,
  "generated_material": "# Алгоритм Кнута-Морриса-Пратта (KMP)\n\n## Введение\n\nАлгоритм Кнута-Морриса-Пратта (KMP) является одним из наиболее эффективных методов поиска подстроки внутри строки. Его ключевая особенность заключается в способности избегать повторных проверок символов, уже проверенных ранее, что делает его значительно эффективнее простых подходов типа полного перебора.\n\nЭтот алгоритм широко используется во многих областях информационных технологий, включая обработку текстов, биоинформатику, компиляторы и системы безопасности. Например, KMP помогает быстро находить ключевые слова в больших документах, анализировать ДНК-последовательности или обнаруживать вредоносные сигнатуры в сетевых пакетах.\n\n## Основная теория\n\n### Задача\n\nПусть даны две строки: образец (`$P$) длиной $|P|$ и текст (`$T$) длиной $|T|$. Необходимо найти все позиции, начиная с которых образец встречается в тексте.\n\n### Принцип работы\n\nОсновной идеей KMP является использование дополнительной информации о самом образце, позволяющей эффективно обрабатывать ситуации, когда происходит несоответствие символов. Для этого предварительно вычисляется специальная таблица — **префикс-функция**, которая хранит сведения о максимальном совпадающем префиксе и суффиксе для всех возможных начальных фрагментов образца.\n\n#### Префикс-функция\n\nДля заданного образца $P$, функция $\\pi[i]$ обозначает максимальную длину собственного префикса, являющегося одновременно суффиксом подстроки $P[0..i]$.\n\nНапример, для образца `'ababaca'`:\n\n$$\n\\pi = [0, 0, 1, 2, 3, 0, 1]\n$$\n\nЭто значит, что:\n- Подстрока `''`: нет общего префикса-суффикса ($\\pi[0] = 0$),\n- Подстрока `'a'`: нет общего префикса-суффикса ($\\pi[1] = 0$),\n- Подстрока `'ab'`: общий префикс-суффикс — пустая строка ($\\pi[2] = 0$),\n- Подстрока `'aba'`: общий префикс-суффикс — `'a'`, длина равна 1 ($\\pi[3] = 1$),\n- ...\n\nЭта информация позволяет нам корректно сдвигать образец при появлении расхождений, минимизируя количество ненужных сравнений.\n\n### Вычисление префикс-функции\n\nВычислить таблицу префикс-функции можно следующим образом:\n\n```python\ndef prefix_function(s):\n    pi = [0] * len(s)\n    j = 0  # Индекс текущего значения префикс-функции\n    \n    for i in range(1, len(s)):\n        while j > 0 and s[i] != s[j]:  # Пока символы не совпадают и можем вернуться назад\n            j = pi[j - 1]\n        \n        if s[i] == s[j]:  # Символы совпадают\n            j += 1\n            \n        pi[i] = j  # Записываем текущее значение префикс-функции\n    \n    return pi\n```\n\n### Процесс поиска\n\nПосле построения префикс-функции основной этап поиска выглядит так:\n\n```python\ndef kmp_search(text, pattern):\n    pi = prefix_function(pattern)\n    n = len(text)\n    m = len(pattern)\n    occurrences = []  # Список найденных позиций\n    q = 0  # Текущая позиция в образце\n    \n    for i in range(n):\n        while q > 0 and text[i] != pattern[q]:  # Обработка расхождений\n            q = pi[q - 1]\n        \n        if text[i] == pattern[q]:  # Совпадение символов\n            q += 1\n        \n        if q == m:  # Полностью найдено соответствие\n            occurrences.append(i - m + 1)\n            q = pi[m - 1]  # Готовимся к следующему возможному соответствию\n    \n    return occurrences\n```\n\n### Пример\n\nДопустим, у нас есть текст `\"abababac\"` и образец `\"ababaca\"`. После вычисления префикс-функции и выполнения поиска результат будет таким:\n\n- Текст: `\"abababac\"`\n- Образец: `\"ababaca\"`\n- Позиция первого появления: `[0]`\n\n### Сложность\n\n- **Временная**: $O(|P|+|T|)$ — поскольку каждый символ проверяется максимум дважды (один раз при вычислении префикс-функции и второй раз при поиске).\n- **Пространственная**: $O(|P|)$ — нужна дополнительная память для хранения префикс-функции.\n\n## Практический пример\n\nНайдем позицию первой встречи образца `\"ababaca\"` в тексте `\"abababac\"`.\n\n```python\ntext = \"abababac\"\npattern = \"ababaca\"\npositions = kmp_search(text, pattern)\nprint(positions)  # Output: [0]\n```\n\n## Сравнение с аналогами\n\n### Другие популярные алгоритмы поиска подстрок:\n\n- **Наивный подход**: Проверяет каждую позицию последовательно, временная сложность $O(|P|\\times|T|)$, неэффективен для длинных текстов.\n  \n- **Алгоритм Рабина-Карпа**: Используется хеширование для быстрого сравнения, эффективен при множественных поисках, но хуже работает с длинными последовательностями одинаковых символов.\n\n- **Алгоритм Бойера-Мура**: Начинает проверку с конца образца, пропускает большие участки текста, но менее предсказуем по производительности.\n\nПреимущества KMP:\n- Гарантированная линейная производительность даже в худшем случае.\n- Не требует дополнительного пространства кроме массива префикс-функции.\n- Эффективен для случаев с частичными совпадениями.\n\nНедостатки:\n- Более сложная реализация по сравнению с простыми методами.\n- Нет встроенной поддержки регулярных выражений.\n\n## Практические советы\n\n1. Всегда заранее строите префикс-функцию перед поиском.\n2. Используйте KMP, когда важна гарантированная линейная производительность.\n3. Убедитесь, что ваш образец и текст представлены в одной кодировке.\n4. Помните про крайние случаи: пустой образец, одинаковые символы подряд.\n5. Тестируйте реализацию на разных типах образцов (случайные, периодические, короткие и длинные).\n\n## Дополнительные ресурсы\n\n- Книга: Томас Х. Кормен, Чарльз Э. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. _«Алгоритмы: построение и анализ»_, Вильямс, 2009 г.\n- Онлайн-ресурсы: Wikipedia, GeeksForGeeks, StackOverflow.\n\nТаким образом, алгоритм Кнута-Морриса-Пратта представляет собой мощный инструмент для эффективного поиска подстрок, особенно полезный там, где критична скорость обработки большого количества данных."
}